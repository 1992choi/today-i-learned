# System Design
- Inflearn > 개발자라면 꼭 알아야할 시스템디자인 완벽가이드

<br><br>

## 개념 정리
### Latency
- 요청(Request)을 보낸 시점부터 응답(Response)을 받기까지 걸리는 시간
- 네트워크 지연, 서버 처리 시간, DB 조회 시간 등 여러 구간의 시간이 합쳐진 값
- 값이 낮을수록 사용자 체감 속도가 빠름

### Throughput
- 단위 시간당 처리할 수 있는 요청(Request)의 양 
- 보통 RPS(Requests Per Second), TPS(Transactions Per Second)로 표현 
- 서버의 CPU, 메모리, 스레드 수, DB 성능 등에 영향을 받음 
- 값이 높을수록 같은 시간에 더 많은 요청을 처리 가능 
- Latency(지연 시간)와는 다른 개념으로, “얼마나 많이 처리하느냐”에 초점이 있음

### 수평확장 vs 수직확장 (Vertical vs Horizontal Scaling)
- 수직 확장(Vertical Scaling)
  - 기존 서버의 CPU, 메모리, 스펙을 업그레이드하는 방식 
  - 구조가 단순하고 관리가 쉽지만, 물리적 한계가 존재하며 비용이 급격히 증가할 수 있음 
  - 서버 1대에 의존하는 구조가 되기 쉬워 SPOF(Single Point Of Failure, 단일 장애 지점)가 발생하기 쉬움 
- 수평 확장(Horizontal Scaling)
  - 동일한 서버를 여러 대로 늘려 부하를 분산하는 방식 
  - 로드 밸런서를 통해 트래픽을 분산하며, 트래픽 증가에 유연하게 대응 가능 
  - 여러 대 중 일부가 장애가 나더라도 전체 서비스가 중단되지 않아 SPOF를 완화할 수 있음
- 비교
  - 수직 확장은 “한 대를 강하게”, 수평 확장은 “여러 대로 나누어” 처리하는 전략이며 고가용성(HA) 관점에서는 일반적으로 수평 확장이 더 유리함

### 로드밸런싱 (Load Balancing)
- 여러 서버에 트래픽을 분산시켜 부하를 고르게 나누는 기술 
- 단일 서버 과부하를 방지하고, 전체 시스템의 Throughput(처리량)을 향상시킴 
- 일부 서버에 장애가 발생해도 다른 서버로 요청을 우회시켜 가용성(Availability)을 높임 
- 대표적인 알고리즘
  - Round Robin
    - 서버에 요청을 순서대로 하나씩 번갈아가며 분배하는 방식으로, 구현이 단순하고 균등 분산에 적합함
  - Least Connections
    - 현재 활성 연결 수가 가장 적은 서버에 요청을 할당하는 방식으로, 실시간 부하 상황을 반영함
  - IP Hash
    - 클라이언트의 IP 값을 해시하여 특정 서버로 고정 매핑하는 방식으로, 세션 유지에 유리함
- 장점
  - 성능 향상
    - 트래픽을 여러 서버에 분산하여 과부하를 줄이고 전체 처리량을 높일 수 있음
  - 고가용성
    - 일부 서버에 장애가 발생해도 다른 서버가 요청을 처리하여 서비스 중단을 최소화함
  - 확장성
    - 서버를 추가하는 것만으로 처리 용량을 유연하게 늘릴 수 있어 트래픽 증가에 대응하기 용이함

### 분산시스템 (Distributed System)
- 여러 대의 서버(노드)가 네트워크를 통해 연결되어 하나의 시스템처럼 동작하는 구조 
- 각 노드는 독립적으로 동작하지만, 협력하여 하나의 서비스나 기능을 제공함 
- 확장성(Scale-out)과 고가용성(HA)을 확보하기 위해 사용됨 
- 장점
  - 확장성
    - 노드를 추가하는 방식으로 시스템 처리 용량을 수평적으로 확장할 수 있어 트래픽 증가에 유연하게 대응 가능함
  - 가용성
    - 일부 노드에 장애가 발생해도 다른 노드가 서비스를 계속 제공하여 전체 시스템 중단을 방지할 수 있음
  - 성능향상
    - 작업을 여러 노드에 분산 처리하여 병렬 수행이 가능하므로 전체 처리 속도와 처리량을 향상시킬 수 있음
- 분산시스템에서의 고려사항
  - 데이터 일관성
    - 여러 노드에 복제된 데이터가 동일한 값을 유지하도록 보장하는 특성
    - 최종적 일관성(Eventual Consistency)
      - 분산 환경에서는 네트워크 지연과 가용성 확보를 위해 모든 노드가 즉시 동일한 값을 가지도록 강제하기 어렵다.
      - 따라서 일시적으로 데이터 차이를 허용하되, 시간이 지나면 결국 모든 노드의 데이터가 동일한 상태로 수렴하도록 하는 모델이 필요하며, 이를 최종적 일관성이라고 한다.
  - 네트워크 지연
    - 노드 간 통신이 네트워크를 통해 이루어지기 때문에 요청과 응답 사이에 발생하는 지연 시간으로, 시스템 성능과 응답 속도에 직접적인 영향을 줌
  - 복잡한 장애처리
    - 일부 노드나 네트워크 구간에서만 장애가 발생하는 부분 장애 상황이 빈번하므로, 이를 전제로 한 장애 감지와 복구 전략이 필요함
    - 하트비트(Heartbeat)
      - 분산 환경에서는 특정 노드가 단순히 느린 것인지, 실제로 장애가 발생한 것인지 구분해야 한다.
      - 이를 위해 각 노드는 주기적으로 자신의 상태를 알리는 신호를 보내며, 이 신호가 일정 시간 동안 감지되지 않으면 장애로 판단한다.
      - 이러한 장애 감지 메커니즘을 하트비트라고 하며, 자동 장애 조치와 서비스 지속성을 위해 필수적인 요소이다.

### CAP 이론 (CAP Theorem)
- 분산시스템에서 Consistency, Availability, Partition Tolerance 세 가지 특성을 동시에 모두 만족할 수 없다는 이론 
- 네트워크 분할(Partition)이 발생한 상황에서는 Consistency와 Availability 중 하나를 선택해야 함 
- 분산 환경에서는 네트워크 장애를 완전히 피할 수 없기 때문에, 실제 설계에서는 P를 전제로 C와 A 중 무엇을 우선할지 결정하는 것이 핵심 
- 특성
  - Consistency 
    - 모든 노드가 동일한 시점에 동일한 데이터를 반환하는 특성 
  - Availability 
    - 일부 노드에 장애가 있어도 시스템이 항상 응답을 반환하는 특성 
  - Partition Tolerance 
    - 노드 간 네트워크가 단절되어도 시스템이 계속 동작할 수 있는 특성
- CAP 조합에 따른 DB 분류 예시
  - CP (Consistency + Partition Tolerance)
    - 네트워크 분할 상황에서도 데이터 일관성을 우선시하며, 대신 일부 요청은 실패할 수 있음 
    - 예시 
      - MongoDB (기본 설정은 CP에 가까움)
  - AP (Availability + Partition Tolerance)
    - 네트워크 분할 상황에서도 항상 응답을 반환하는 것을 우선시하며, 대신 일시적으로 데이터 불일치를 허용함 (최종적 일관성)
    - 예시 
      - Cassandra 
      - DynamoDB 
  - CA (Consistency + Availability)
    - 네트워크 분할이 없다는 전제하에 일관성과 가용성을 모두 만족 
    - 하지만 실제 분산 환경에서는 Partition을 완전히 배제할 수 없기 때문에 이 조합은 단일 노드 시스템에 가까움 
    - 예시 
      - MySQL (단일 인스턴스 기준)
        - Master / Slave(Primary / Replica) 구조로 확장하는 경우 분산 시스템이 되며, 복제 방식에 따라 성향이 달라짐 
        - 비동기 복제(Async Replication)를 사용하는 일반적인 읽기 분산 구조는 Slave 지연을 허용하므로 AP 성향에 가까움 
        - 반대로, 동기화 수준을 높여 일관성을 강하게 보장하는 구성(Semi-sync 등)은 분할 시 쓰기를 제한할 수 있어 CP 성향에 가까워짐
      - PostgreSQL (단일 인스턴스 기준)

### 장애조치 (Failover)
- Failover란?
  - 시스템에서 장애가 발생했을 때, 정상 동작 중인 다른 서버나 노드가 자동으로 역할을 넘겨받아 서비스를 지속하는 메커니즘
- Failover를 대비한 시스템 구조
  - Primary
    - 실제로 트래픽을 처리하거나 쓰기 작업을 담당하는 주 서버로, 장애 발생 시 교체 대상이 되는 노드
  - Secondary
    - Primary의 상태를 대기하며 데이터 동기화 또는 복제를 유지하다가, Primary 장애 시 역할을 승계하는 예비 서버
- Active - Active / Active - Passive
  - Active - Active
    - 여러 노드가 동시에 요청을 처리하는 구조로, 부하 분산과 자원 활용도가 높지만 데이터 정합성 관리가 더 복잡함
  - Active - Passive
    - 한 노드만 실제로 서비스하고, 나머지는 대기 상태로 있다가 장애 시 전환되는 구조로, 구현이 비교적 단순함
- RTO / RPO
  - RTO (Recovery Time Objective)
    - 장애 발생 후 서비스를 복구하는 데 허용 가능한 최대 시간
  - RPO (Recovery Point Objective)
    - 장애 발생 시점 기준으로, 유실을 허용할 수 있는 데이터의 최대 시점 범위
- Health Check
  - 개념
    - 서버나 애플리케이션의 정상 동작 여부를 주기적으로 확인하여 장애를 탐지하는 메커니즘
  - 단순 ping으로만 판단하면 안되는 이유
    - 서버 프로세스는 살아있더라도 DB 연결 실패, 스레드 고갈, 내부 오류 등으로 실제 서비스는 불가능할 수 있으므로, 애플리케이션 레벨의 상태(예: DB 연결, 주요 의존성 상태 등)까지 확인하는 헬스 체크가 필요함

### 정족수 (Quorum)
- 정족수 (Quorum)란?
  - 분산 시스템에서 특정 작업이나 결정을 수행하기 위해 필요한 최소 동의 노드 수를 의미함
  - 클러스터 내 다수 노드의 동의를 기반으로 쓰기 승인, 리더 선출, 장애 판단 등을 수행하는 기준으로 사용됨
- 필요한 이유
  - 데이터 일관성
    - 과반수 이상의 노드가 동일한 데이터를 승인하도록 하여 오래된 데이터나 충돌 데이터를 방지함
  - 장애 대응
    - 일부 노드가 장애를 일으켜도 다수 노드 기준으로 정상 여부를 판단하여 시스템을 안정적으로 유지함
  - 의사 결정
    - 리더 선출이나 설정 변경 등 중요한 작업을 다수결로 결정하여 신뢰성을 확보함
- Split Brain
  - 네트워크 분할 등으로 클러스터가 둘 이상의 그룹으로 나뉘고, 각각이 자신이 정상이라고 판단해 동시에 동작하는 현상
  - 방지하는 방법
    - 홀수 개의 노드 사용
      - 과반수 계산이 명확해져 한쪽 그룹만 정족수를 만족하도록 만들어 Split Brain 가능성을 줄임
    - 쿼럼 기반 의사 결정
      - 과반수 이상 동의를 얻은 그룹만 리더 선출이나 쓰기를 허용하도록 하여 다중 리더 발생을 방지함
- 분산시스템에서의 정족수 사용 예시
  - Apache ZooKeeper
    - 분산 시스템에서 리더 선출, 설정 관리, 분산 락과 같은 조정 작업을 담당하는 시스템
    - 클러스터는 Leader 1대와 여러 Follower로 구성되며, 리더 선출 시 과반수(Quorum) 동의를 받아야 함
    - 과반수를 확보하지 못하면 잘못된 리더 선출을 방지하기 위해 쓰기 작업을 중단함
  - Kafka에서의 ISR
    - 하나의 파티션은 Leader와 여러 Follower로 구성됨
    - ISR(In-Sync Replicas)은 Leader와 동기화가 완료된 복제본들의 집합을 의미함
    - 프로듀서의 acks 설정이 all인 경우, ISR에 포함된 노드까지 데이터가 복제되어야 쓰기 성공으로 처리됨
    - 즉, ISR은 최신 상태를 유지하는 복제 집합을 관리하여 사실상 정족수 기반 안정성을 보장하는 역할을 수행함

### HTTP
- HTTP 란?
  - HyperText Transfer Protocol의 약자로, 클라이언트와 서버 간에 데이터를 주고받기 위한 애플리케이션 계층 프로토콜
  - 웹 브라우저와 웹 서버 간 통신의 기본이 되며, 요청(Request)과 응답(Response) 구조로 동작함
- 특징
  - 무상태성
    - 각 요청은 서로 독립적이며, 이전 요청의 상태를 서버가 자동으로 기억하지 않음
    - 따라서 로그인 유지 등을 위해 쿠키, 세션, 토큰과 같은 별도 상태 관리 방식이 필요함
- HTTP 메서드
  - GET
    - 서버로부터 리소스를 조회할 때 사용하며, 요청 본문 없이 URL을 통해 데이터 전달
  - POST
    - 서버에 데이터를 생성하거나 처리 요청을 보낼 때 사용하며, 요청 본문에 데이터를 포함
  - PUT
    - 특정 리소스를 전체 수정하거나 새로 생성할 때 사용
  - DELETE
    - 특정 리소스를 삭제할 때 사용
- HTTP 상태코드
  - 200번대 (성공)
    - 200 OK: 요청 성공
    - 201 Created: 리소스 생성 성공
    - 204 No Content: 성공했지만 반환할 데이터 없음
  - 300번대 (리다이렉션)
    - 301 Moved Permanently: 영구 이동
    - 302 Found: 임시 이동
    - 304 Not Modified: 캐시된 리소스 사용
  - 400번대 (클라이언트 오류)
    - 400 Bad Request: 잘못된 요청
    - 401 Unauthorized: 인증 필요
    - 403 Forbidden: 접근 권한 없음
    - 404 Not Found: 리소스를 찾을 수 없음
  - 500번대 (서버 오류)
    - 500 Internal Server Error: 서버 내부 오류
    - 502 Bad Gateway: 게이트웨이 오류
    - 503 Service Unavailable: 서비스 일시 불가
    - 504 Gateway Timeout: 게이트웨이 시간 초과
- HTTP 헤더
  - Content-Type
    - 전송하는 데이터의 형식을 명시 (예: application/json)
  - Authorization
    - 인증 정보를 서버에 전달할 때 사용 (예: Bearer 토큰)
  - Cookie
    - 클라이언트에 저장된 쿠키 정보를 서버로 전달
  - Cache-Control
    - 캐시 정책을 제어
  - User-Agent
    - 요청을 보낸 클라이언트의 정보(브라우저, OS 등)를 포함

### TCP / UDP
- TCP 란?
  - Transmission Control Protocol의 약자로, 신뢰성 있는 데이터 전송을 보장하는 연결지향형 전송 계층 프로토콜
- TCP의 특징
  - 연결지향 및 3way handshake
    - 통신 전에 SYN → SYN+ACK → ACK 과정을 통해 연결을 설정한 뒤 데이터를 송수신함
  - 신뢰성 보장
    - 데이터 손실 시 재전송을 수행하고, 순서를 보장하며, 중복 데이터를 제거함
  - 흐름제어
    - 수신 측의 처리 속도를 고려하여 Window Size 기반으로 전송량을 조절함
  - 혼잡제어
    - 네트워크 혼잡 상황을 감지하여 전송 속도를 조절함 (Slow Start, Congestion Avoidance 등)
- TCP가 적합한 경우와 단점
  - 적합한 경우
    - 파일전송
      - 데이터 유실 없이 정확한 전송이 필요하므로 신뢰성이 중요한 경우에 적합함
    - 이메일
      - 메시지 내용이 손상 없이 전달되어야 하므로 안정성이 중요함
  - 단점
    - 연결 설정 및 해제 과정으로 인한 오버헤드가 존재함
    - 재전송 및 혼잡제어로 인해 지연이 발생할 수 있음
    - 실시간성이 중요한 서비스에는 부적합할 수 있음
- UDP 란?
  - User Datagram Protocol의 약자로, 연결 설정 없이 데이터를 빠르게 전송하는 비연결형 전송 계층 프로토콜
- UDP의 특징
  - 비연결형
    - 사전 연결 설정 없이 바로 데이터를 전송함
  - 신뢰성 낮음
    - 데이터 손실, 중복, 순서 뒤바뀜에 대해 보장하지 않음
  - 빠른 전송 속도
    - 연결 과정과 재전송 절차가 없어 지연이 적음
  - 작은 헤더
    - TCP보다 헤더 구조가 단순하고 크기가 작아 오버헤드가 적음
- UDP가 적합한 경우와 단점
  - 적합한 경우
    - 실시간 스트리밍
      - 일부 데이터 손실이 발생하더라도 지연이 적은 것이 중요한 경우에 적합함
    - 온라인 게임
      - 빠른 응답 속도가 중요하며, 일부 패킷 손실은 보완 가능함
    - VoIP
      - 음성 통화는 지연이 최소화되는 것이 중요함
  - 단점
    - 데이터 유실 시 자동 복구가 없음
    - 순서 보장이 없어 애플리케이션 레벨에서 추가 처리 필요
    - 혼잡제어 기능이 없어 네트워크 품질에 직접적인 영향을 받음

### API 설계
- API 설계의 중요성
  - 규약이기 때문
    - API는 서버와 클라이언트 간의 계약(Contract) 역할을 하며, 요청 방식·응답 구조·에러 형식 등을 명확히 정의한 약속임
    - 이 규약이 불명확하면 클라이언트와 서버 간 해석 차이가 발생하고, 유지보수 비용이 크게 증가함
    - 여러 팀 또는 외부 파트너와 협업하는 경우, API는 문서화된 공식 인터페이스로서 시스템 경계를 정의함
  - 한번 공개하면 바꾸기 어려움
    - 이미 배포된 API는 이를 사용하는 클라이언트가 존재하므로, 구조 변경 시 호환성 문제가 발생함
    - 하위 호환성을 고려하지 않은 변경은 장애로 이어질 수 있어 신중한 설계가 필요함
- 잘 설계된 API의 특징
  - 직관적이고 예측 가능
    - 엔드포인트 구조만 보아도 어떤 리소스를 다루는지 쉽게 이해할 수 있어야 함
    - 예측 가능한 URL 패턴과 응답 형식을 유지해야 학습 비용이 낮아짐
  - 일관성
    - 네이밍, 응답 포맷, 상태코드 사용 방식이 전반적으로 통일되어야 함
    - 복수형 리소스, snake_case 또는 camelCase 등 규칙을 일관되게 유지해야 함
  - 간결하고 필요한 응답만 제공
    - 불필요한 데이터까지 포함하면 네트워크 비용과 파싱 비용이 증가함
    - 필요한 필드만 선택적으로 조회할 수 있도록 설계하는 것이 바람직함
  - 명확한 에러 처리
    - HTTP 상태코드를 상황에 맞게 정확히 사용해야 함
    - 에러 코드, 메시지, 상세 정보를 구조화하여 클라이언트가 원인을 파악할 수 있어야 함
  - 버저닝 전략
    - v1, v2와 같이 명시적으로 버전을 관리하여 하위 호환성을 유지해야 함
    - URI 버전, 헤더 기반 버전 등 전략을 사전에 정의하는 것이 중요함
  - 적절한 페이지네이션 및 필터링
    - 대량 데이터 조회 시 limit, offset 또는 cursor 기반 페이지네이션을 제공해야 함
    - 검색 조건, 정렬 기준 등을 파라미터로 명확히 지원해야 함
  - 리소스는 명사로 행위는 HTTP 메서드로 표현
    - URL에는 행위 동사를 사용하지 않고 리소스를 명사 형태로 표현해야 함
    - 생성, 조회, 수정, 삭제는 각각 POST, GET, PUT/PATCH, DELETE로 구분하는 것이 RESTful 설계 원칙에 부합함

### API Proxy
- Proxy란?
  - 클라이언트와 서버 사이에서 요청과 응답을 대신 전달하는 중계 서버
  - 직접 통신하지 않고, 프록시를 거쳐 통신함으로써 트래픽 제어·보안·캐싱 등의 기능을 수행함
- Proxy의 종류
  - Forward Proxy
    - 연결의 클라이언트 측에 위치
    - 클라이언트 대신 외부 서버와 통신을 수행함
    - 역할
      - 캐싱
        - 자주 요청되는 리소스를 저장해 두었다가 재사용하여 응답 속도를 개선함
      - 접근 제어
        - 특정 사이트 차단, 인증 기반 접근 통제 등 클라이언트의 외부 접근을 제어함
  - Reverse Proxy
    - 백엔드 서버 앞단에 위치
    - 클라이언트 요청을 받아 내부 서버로 전달하고, 응답을 다시 클라이언트에 반환함
    - 역할
      - 로드밸런싱
        - 여러 서버에 요청을 분산하여 트래픽을 균등하게 처리함
      - 보안
        - 실제 서버 정보를 숨기고, SSL 종료 및 방화벽 역할을 수행함
      - 로깅
        - 요청 및 응답 기록을 중앙에서 수집함
      - 모니터링
        - 트래픽 현황과 서버 상태를 추적하여 운영 가시성을 확보함
- API Gateway
  - 본질적으로는 리버스 프록시의 한 형태임
  - 클라이언트의 모든 API 요청을 단일 진입점(Single Entry Point)에서 받아 내부 마이크로서비스로 라우팅함
  - 인증·인가 처리(JWT 검증 등), 요청 변환, 응답 통합, 속도 제한(Rate Limiting) 등을 수행함
  - 공통 기능을 중앙화하여 각 서비스가 비즈니스 로직에 집중할 수 있도록 지원함

### API 회복탄력성
- 회복탄력성이란?
  - 시스템에 장애나 예상치 못한 과부하가 발생했을 때, 서비스의 핵심 기능을 유지하며 빠르게 정상 상태로 복구하는 능력
- Rate Limit
  - 개념
    - 일정 시간 동안 허용할 수 있는 요청 수를 제한하여 트래픽을 제어하는 기법
  - 특징
    - 서버자원 보호
      - 과도한 요청으로부터 CPU, 메모리, DB 등의 자원을 보호함
    - 공정한 자원분배
      - 특정 사용자나 클라이언트가 자원을 독점하지 못하도록 방지함
    - 비용절감
      - 불필요한 트래픽을 제한하여 인프라 확장 비용을 줄일 수 있음
  - 주요 알고리즘
    - Token Bucket
      - 일정 속도로 토큰을 채우고, 요청이 들어올 때 토큰을 차감하는 방식으로 순간적인 트래픽 버스트를 허용함
    - Leaky Bucket
      - 고정된 속도로 요청을 처리하여 일정한 처리율을 유지함
    - Fixed Window
      - 정해진 시간 구간 단위로 요청 수를 제한하는 단순한 방식
    - Sliding Window
      - 이전 구간의 요청 수를 일부 반영하여 보다 부드럽게 트래픽을 제어하는 방식
- Throttling
  - 개념
    - 시스템 부하 상황에 따라 요청 처리 속도를 의도적으로 늦추거나 제한하는 기법
  - 종류
    - 큐 기반 Throttling
      - 요청을 즉시 처리하지 않고 큐에 적재한 뒤 순차적으로 처리함
    - 우선순위 기반 Throttling
      - 요청 중요도에 따라 처리 순서를 다르게 적용함
    - 동적 Throttling
      - 서버 상태(CPU, 메모리 등)에 따라 실시간으로 제한 수준을 조정함
- Circuit Breaker
  - 개념
    - 특정 서비스 호출이 반복적으로 실패할 경우, 일정 시간 동안 호출을 차단하여 장애 확산을 방지하는 패턴
  - 특징
    - 연쇄 장애 방지
      - 하나의 서비스 장애가 전체 시스템으로 확산되는 것을 차단함
    - 빠른 실패
      - 실패가 예상되는 요청을 즉시 차단하여 대기 시간을 줄임
    - 자동 복구
      - 일정 시간이 지나면 Half-Open 상태로 전환하여 정상 여부를 재확인함
    - 리소스 낭비 방지
      - 불필요한 재시도 호출을 줄여 시스템 자원을 보호함
- Timeout
  - 개념
    - 요청 또는 연결이 일정 시간 내에 완료되지 않으면 강제로 종료하는 설정
  - 특징
    - 리소스 고갈 방지
      - 무한 대기를 방지하여 스레드와 커넥션 자원 고갈을 막음
    - 사용자 경험 개선
      - 응답이 지연될 경우 빠르게 오류를 반환하여 대기 시간을 줄임
  - 종류
    - Connection timeout
      - 서버와 연결을 맺는 데 허용되는 최대 시간
    - Read timeout
      - 연결 후 응답 데이터를 읽는 데 허용되는 최대 시간
    - Request timeout
      - 요청 전체 처리에 허용되는 최대 시간

### 트랜잭션
- 트랜잭션이란?
  - 데이터베이스에서 하나의 논리적 작업 단위를 의미
  - 여러 개의 SQL이 하나의 작업처럼 묶여 전부 성공하거나 전부 실패해야 하는 실행 단위
  - 데이터의 일관성과 무결성을 보장하기 위한 메커니즘
- 커밋과 롤백
  - Commit
    - 트랜잭션 내 작업을 최종적으로 반영
    - 데이터 변경 사항이 영구 저장
    - 다른 트랜잭션에서 해당 변경 내용 조회 가능
  - Rollback
    - 트랜잭션 내 작업을 모두 취소
    - 오류 발생 시 이전 상태로 복구
    - 부분 반영 없이 일관된 상태 유지

### ACID 원칙
- Atomicity(원자성)
  - 모두 성공하거나 모두 실패
- Consistency(일관성)
  - 트랜잭션 전후로 데이터 무결성 유지
- Isolation(격리성)
  - 동시에 실행되는 트랜잭션 간 간섭 최소화
- Durability(지속성)
  - 커밋된 데이터는 영구적으로 보존
    
### 격리수준
- 부정합 문제의 종류
  - Dirty Read
    - 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 현상
    - 이후 롤백되면 존재하지 않는 데이터를 읽은 것이 됨
  - Non-Repeatable Read
    - 한 트랜잭션 내에서 같은 조회를 두 번 했을 때 결과가 달라지는 현상
    - 다른 트랜잭션이 중간에 수정 후 커밋했기 때문
  - Phantom Read
    - 같은 조건으로 조회했을 때, 이전에 없던 행이 새로 나타나는 현상
    - 다른 트랜잭션이 조건에 맞는 데이터를 삽입 후 커밋했기 때문
  - Lost Update
    - 두 트랜잭션이 같은 데이터를 동시에 수정하면서 한 쪽 변경이 덮어씌워지는 현상
- 격리레벨
  - Read Uncommitted
    - 가장 낮은 격리 수준
    - Dirty Read, Non-Repeatable Read, Phantom Read 모두 발생 가능
  - Read Committed
    - 커밋된 데이터만 조회 가능
    - Dirty Read는 방지
    - Non-Repeatable Read, Phantom Read는 발생 가능
  - Repeatable Read
    - 트랜잭션 내 동일한 행 조회 시 항상 같은 결과 보장
    - Dirty Read, Non-Repeatable Read 방지
    - Phantom Read는 발생 가능
  - Serializable
    - 가장 높은 격리 수준
    - 모든 부정합 문제 방지
    - 동시성이 가장 낮고 성능 부담이 큼

### 인덱싱
- 인덱스란?
  - 데이터베이스에서 조회 성능을 향상시키기 위해 사용하는 자료구조
  - 특정 컬럼의 값을 기준으로 정렬된 구조를 만들어 탐색 범위를 줄이는 역할
  - 일반적으로 B-Tree 기반 구조를 사용
  - 조회(SELECT)는 빨라지지만, INSERT/UPDATE/DELETE 시에는 추가 비용 발생
- 카디널리티란
  - 특정 컬럼이 가지는 고유 값의 개수
  - 카디널리티가 높을수록(중복이 적을수록) 인덱스 효율이 좋음
  - 예: 주민등록번호는 카디널리티가 높고, 성별 컬럼은 카디널리티가 낮음
  - 낮은 카디널리티 컬럼은 인덱스를 사용해도 성능 개선 효과가 크지 않을 수 있음
- 인덱스를 적용할 때 간과하기 쉬운 요소 (데이터 분포 관점)
  - 값이 한쪽에 치우쳐 있다면, 통계 정보와 실제 분포가 달라 실행 계획이 비효율적으로 선택될 수 있음
  - 특정 값에 조회가 집중되는 경우, 인덱스를 타더라도 많은 레코드를 읽게 되어 성능 이점이 줄어듦
  - 따라서 인덱스 설계 시 단순히 컬럼 존재 여부가 아니라, 실제 데이터 특성과 조회 패턴을 함께 고려해야 함

### 레플리케이션
- 레플리케이션이란?
  - 데이터베이스 또는 분산 시스템에서 데이터를 여러 노드에 복제하여 저장하는 방식
  - 가용성과 확장성, 장애 대응 능력을 높이기 위한 구조
  - 하나의 노드에 장애가 발생해도 다른 노드를 통해 서비스 지속 가능
- 종류
  - 리더 - 팔로워
    - 하나의 리더 노드가 쓰기를 담당하고, 팔로워 노드들이 데이터를 복제
    - 읽기 부하를 팔로워로 분산 가능
    - 리더 장애 시 승격(Failover) 필요
  - 리더 - 리더
    - 여러 노드가 동시에 쓰기를 처리
    - 지리적으로 분산된 환경에서 유리
    - 충돌(conflict) 해결 전략이 반드시 필요
- 일관성을 어떻게 맞출 것인가?
  - 최종 작성자 우선
    - 동일 데이터 충돌 시 가장 마지막에 기록된 값을 선택
    - 구현이 단순하지만 데이터 유실 가능성 존재
  - 합의 알고리즘
    - 다수 노드의 동의를 받아 값을 확정
    - 강한 일관성을 보장하지만 지연 증가 가능
  - 쿼럼 기반 방식
    - 읽기/쓰기 시 일정 수 이상의 노드 응답을 요구
    - 가용성과 일관성 사이의 균형 조절 가능
  - 궁극적 일관성
    - 일정 시간이 지나면 모든 노드의 데이터가 동일해짐을 보장
    - 즉각적인 강한 일관성은 보장하지 않음
    - 대규모 분산 시스템에서 자주 사용되는 모델

### 파티셔닝/샤딩
- 파티셔닝
  - 개념
    - 하나의 데이터베이스 내에서 테이블을 논리적으로 분할하는 방식
    - 물리적으로는 같은 서버, 같은 DB 인스턴스에 존재
    - 주로 범위(Range), 리스트(List), 해시(Hash) 기준으로 분할
    - 대용량 테이블의 조회 성능 개선 및 관리 편의성 향상 목적
    - 파티션 단위로 백업, 삭제, 아카이빙이 가능
- 샤딩
  - 개념
    - 데이터를 여러 데이터베이스 서버에 분산 저장하는 방식
    - 각 서버는 전체 데이터의 일부만 보유
    - 보통 샤드 키(Shard Key)를 기준으로 데이터 분산
    - 수평 확장을 위한 대표적인 구조
  - 샤딩이 필요한 이유
    - 단일 DB 서버의 CPU, 메모리, 디스크 한계 극복
    - 트래픽 증가에 따른 부하 분산
    - 저장 용량 확장
    - 특정 서비스 단위 또는 테넌트 단위로 데이터 격리 가능
    - 장애 발생 시 전체 시스템 영향 최소화

### NoSQL
- NoSQL이란?
  - Not Only SQL의 약자
  - 관계형 데이터베이스(RDBMS)와 달리 고정된 스키마 없이 데이터를 저장하는 데이터베이스
  - 대규모 분산 환경에서 수평 확장에 유리하도록 설계된 저장소
  - 빅데이터, 실시간 처리, 높은 트래픽 환경에서 주로 사용
- NoSQL의 특징
  - 확장성
    - 수직 확장(Scale-up)보다 수평 확장(Scale-out)에 최적화
    - 서버를 추가하여 처리량 증가 가능
    - 분산 구조를 기본 전제로 설계
  - 유연성
    - 스키마가 고정되어 있지 않음
    - JSON 형태 등 다양한 구조 저장 가능
    - 서비스 요구사항 변경에 유연하게 대응
  - 고성능
    - 단순한 데이터 모델로 빠른 읽기/쓰기 처리
    - 특정 접근 패턴에 최적화된 구조 제공
    - 캐시, 로그, 세션 저장 등에서 높은 처리량 제공
- 데이터 모델에 따른 분류
  - Key-Value Store
    - Key를 통해 Value를 조회하는 단순 구조
    - 캐시, 세션 저장소에 적합
    - 예: Redis
  - Document Store
    - JSON, BSON 형태의 문서 단위 저장
    - 문서 내부 필드 기준 조회 가능
    - 예: MongoDB
  - Column-Family Store
    - 컬럼 그룹 단위로 데이터를 저장
    - 대규모 분산 환경에서 쓰기 성능에 강점
    - 예: Apache Cassandra
  - Graph Database
    - 노드와 엣지 기반으로 관계를 저장
    - 관계 탐색 쿼리에 최적화
    - 예: Neo4j

### 데이터 저장소 성격
- Hot 스토리지
  - 자주 접근되는 데이터를 저장하는 영역
  - 낮은 지연 시간과 높은 처리 성능이 요구됨
  - 일반적으로 SSD, 인메모리 저장소 등을 사용
  - 실시간 조회, 트랜잭션 처리, 최근 데이터에 적합
- Warm 스토리지
  - 일정 주기로 조회되지만 실시간성이 크게 요구되지 않는 데이터 저장 영역
  - Hot 대비 비용은 낮고, Cold 대비 접근 속도는 빠른 중간 계층
  - 로그, 최근 이력 데이터 등에 적합
  - 성능과 비용의 균형을 고려한 구조
- Cold 스토리지
  - 거의 접근하지 않는 데이터를 장기 보관하는 영역
  - 접근 속도는 느리지만 저장 비용이 저렴
  - 백업, 아카이빙, 규정 준수 목적의 데이터에 적합
  - 복구 시 지연 시간이 발생할 수 있음

### 데이터베이스 선택 기준
- 데이터 구조와 유연성
  - 정형화된 스키마가 필요한지 여부
  - 스키마 변경이 자주 발생하는지 여부
  - 관계 중심 모델인지, 문서/키-값 중심 모델인지 고려
  - 트랜잭션 무결성이 중요한지 판단
- 읽기 vs 쓰기 비중
  - 읽기 중심 서비스인지, 쓰기 중심 서비스인지 분석
  - 읽기 트래픽이 많다면 캐시, 읽기 복제본(Replica) 고려
  - 쓰기 트래픽이 많다면 파티셔닝, 샤딩 구조 검토
  - 일괄 처리(batch)인지, 실시간 처리인지도 중요한 요소
- 확장성 전략
  - 수직 확장(Scale-up) 중심인지 수평 확장(Scale-out) 중심인지 결정
  - 단일 노드 고성능 구조인지, 분산 시스템 기반 구조인지 선택
  - 장애 대응을 위한 레플리케이션 구조 필요 여부 판단
  - 트래픽 증가에 따른 확장 비용 예측
- CAP 이론
  - Consistency(일관성), Availability(가용성), Partition Tolerance(분할 허용성) 간의 트레이드오프
  - 네트워크 분할 상황에서 세 가지를 동시에 완벽히 만족할 수 없음
  - 강한 일관성이 중요한지, 높은 가용성이 중요한지 우선순위 설정
  - 서비스 특성에 맞는 AP, CP 성향 데이터베이스 선택