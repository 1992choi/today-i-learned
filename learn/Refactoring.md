# 개요
- 인프런의 '코딩으로 학습하는 리팩토링'

### 냄새 1. 이해하기 힘든 이름
- 개요
  - 깔끔한 코드에서 가장 중요한 것 중 하나가 바로 '좋은 이름'이다.
  - 함수, 변수, 클래스, 모듈의 이름 등 모두 어떤 역할을 하는지 어떻게 쓰이는지 직관적이어야 한다.
- 관련 리팩토링
  - 함수 선언 변경하기 (Change Function Declaration)
  - 변수 이름 바꾸기 (Rename Variable)
  - 필드 이름 바꾸기 (Rename Field)

### 냄새 2. 중복 코드
- 개요
  - 중복 코드가 존재하며 이를 변경하려고 할 때, 동일한 모든 곳의 코드를 변경하지 않으면 오류가 발생할 확률이 높아진다.
- 관련 리팩토링
  - 함수 추출하기 (Extract Function)
    - '의도'와 '구현' 분리하기
      - 어떠한 목적(=의도)을 위해 기술되었는지가 없으면 구현을 위한 코드일 가능성이 높다.
      - 이는 가독성을 낮추므로 분리할 필요가 있다.
  - 코드 정리하기 (Slide Statements)
    - 관련있는 코드끼리 묶여있어야 코드를 더 쉽게 이해할 수 있다.
    - 함수에서 사용할 변수를 상단에 미리 정의하기 보다는, 해당 변수를 사용하는 코드 바로 위에 선언.
    - 관련있는 코드끼리 묶은 다음, 함수 추출하기 (Extract Function)를 사용해서 더 깔끔하게 분리.
  - 메서드 올리기 (Pull Up Method)
    - 여러 하위 클래스에 동일한 코드가 있다면, 상위 클래스로 메서드를 올린다.

### 냄새 3. 긴 함수
- 개요
  - 함수가 길면 가독성이 좋지 못할 수 있다.
    - 무조건 짧은 함수가 좋다는 건 아니다. 짧은 함수는 더 많은 문맥 전환을 필요로 한다.
    - 또한 작은 단위의 함수는 더 많은 서브루틴 호출로 인한 오버헤드가 발생할 수 있다. (요즘은 PC 성능이 좋아져 무시할만한 수준)
  - 함수를 작게 나눈 후 '좋은 이름'을 사용한다면, 함수의 이름만 보고 기능을 짐작할 수 있다.
  - 거의 대부분은 '함수 추출하기'로 해결할 수 있다.
- 관련 리팩토링
  - 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)
  - 매개변수 객체 만들기 (Introduce Parameter Object)
    - 같은 매개변수들이 여러 메서드에 걸쳐 나타난다면 그 매개변수들을 묶은 자료 구조를 만들 수 있다.
  - 객체 통째로 넘기기 (Preserve Whole Object)
    - 어떤 한 레코드에서 구할 수 있는 여러 값들을 함수에 전달하는 경우, 해당 매개변수를 레코드 하나로 교체할 수 있다.
    - 매개변수 목록을 줄일 수 있다는 장점이 있지만, 의존성이 생길 수도 있다.
  - 조건문 분해하기 (Decompose Conditional)
    - 기술적으로는 '함수 추출하기'와 동일한 리팩토링이지만 의도만 다를 뿐이다.
  - 조건문을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)
    - 여러 타입에 따라 각기 다른 로직으로 처리해야 하는 경우에 다형성을 적용해서 조건문을 보다 명확하게 분리할 수 있다.
  - 반복문 쪼개기 (Split Loop)
    - 하나의 반복문에서 여러 다른 작업을 하는 코드를 쉽게 찾아볼 수 있는데, 이를 쪼개는 작업이다.
      - ex. 하나의 for문 안에서 여러 실행코드가 있다고하면, 동일한 반복문을 쪼개서 관심사 별로 묶는 기법 
      - 성능 문제를 야기할 수 있지만, '리팩토링'은 '성능 최적화'와 별개의 작업이다. 리팩토링을 마친 이후에 성능 최적화 시도할 수 있다.

### 냄새 4. 긴 매개변수 목록
- 개요
  - 매개변수가 많을수록 함수의 역할을 이해하기 어려워진다.
  - 매개변수를 다시 확인할 필요성이 있다.
    - 과연 그 함수는 한가지 일을 하고 있는게 맞는가?
    - 불필요한 매개변수는 없는가?
    - 하나의 레코드로 뭉칠 수 있는 매개변수 목록은 없는가?
- 관련 리팩토링
  - 객체 통째로 넘기기 (Preserve Whole Object)
  - 매개변수 객체 만들기 (Introduce Parameter Object)
  - 여러 함수를 클래스로 묶기 (Combine Functions into Class)
    - 위 3개 방법은 작은 단위에 매개변수가 반복된다면 하나의 틀로 묶어서 전달하는 것을 의미한다.
  - 매개변수를 질의 함수로 바꾸기 (Replace Parameter with Query)
    - 매개 변수 중 isPremium 이라는 값이 있으며, 이를 통해서 내부적으로 계산식이 분기된다고 가정할 때, 매개 변수를 넘기지 않고 해당 메서드 내에서 특정 함수를 호출하여 구할 수 있다면 매개변수 삭제가 가능하다.
  - 플래그 인수 제거하기 (Remove Flag Argument)
    - 매개변수가 플래그로 사용된다면, 하나의 메서드가 다양한 일을 하고 있을 수 있다.
    - 메서드를 적절히 분리할 수 있는지 파악한다.

### 냄새 5. 전역 데이터
- 개요
  - 전역 데이터는 아무곳에서나 변경될 수 있다는 문제가 있다.
  - 어떤 코드로 인해 값이 바뀐 것인지 파악하기 어렵다.
- 관련 리팩토링
  - 변수 캡슐화 (Encapsulate Variable)
    - 데이터가 사용되는 범위가 클수록 캡슐화를 하는 것이 더 중요해진다.
    - 캡슐화를 통해 데이터 변경에 따른 검증 로직을 쉽게 추가할 수도 있다.
  - 불변 데이터 사용
    - 값이 한 번 할당된 이후 변경사항이 생길 일이 없다면, 불변 데이터를 사용하는 것도 좋은 방안이다.
    
### 냄새 6. 가변 데이터
- 개요
  - 데이터를 변경하다보면 예상치 못했던 결과나 해결하기 어려운 버그가 발생하기도 한다.
  - 변경되는 데이터 사용 시 발생할 수 있는 리스크를 관리할 수 있는 방법을 적용하는 것이 좋다.
- 관련 리팩토링
  - 변수 쪼개기 (Split Variable)
    - 변수가 여러번 재할당 되어도 적절한 경우
      - 반복문에서 순회하는데 사용하는 변수 또는 인덱스
      - 값을 축적시키는데 사용하는 변수
    - 그 밖에 경우에 재할당 되는 변수가 있다면 변수를 분리해야 더 이해하기 좋은 코드를 만들 수 있다.
  - 질의 함수와 변경 함수 분리 (Separate Query from Modifier)
    - 사이드 이팩트 없이 값을 조회할 수 있는 메서드는 테스트 하기도 쉽고, 메서드를 이동하기도 편하다.
    - 명령-조회 분리 (command-query separation) 규칙
      - 조회하는 함수와 값을 변경하는 함수가 있다면 분리하라는 의미
  - 세터 제거하기 (Remove Setting Method)
    - 객체 생성시 처음 설정된 값이 변경될 필요가 없다면 해당 값을 설정할 수 있는 생성자를 만들고 세터를 제거해서 변경될 수 있는 가능성을 제거한다.
  - 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)
    - 계산해서 알아낼 수 있는 변수는 제거할 수 있다.
      - 계산 자체가 데이터의 의미를 잘 표현하는 경우도 있다.
      - 해당 변수가 어디선가 잘못된 값으로 수정될 수 있는 가능성을 제거할 수 있다.
  - 여러 함수를 변환 함수로 묶기 (Combine Functions into Transform)
    - 관련있는 여러 파생 변수를 만들어내는 함수가 여러곳에서 만들어지고 사용된다면 그러한 파생 변수를 '변환 함수 (transform function)'를 통해 한 곳으로 모아둘 수 있다.
  - 참조를 값으로 변경 (Change Reference to Value)
    - 원시 데이터는 주소값을 공유하지 않기 때문에 사이드 이펙트가 발생할 확률이 적다.
    - 어떤 객체의 변경 내역을 다른 곳으로 전파시키고 싶다면 레퍼런스, 아니라면 값 객체(=원시 데이터)를 사용한다.

### 냄새 7. 뒤엉킨 변경
- 개요
  - 소프트웨어는 변경에 유연하게(soft) 대처할 수 있어야 한다.
  - 어떤 한 모듈이 (함수 또는 클래스가) 여러가지 이유로 다양하게 변경되어야 하는 상황.
    - 서로 다른 문제는 서로 다른 모듈에서 해결해야 한다.
    - 모듈의 책임이 분리되어 있을수록 해당 문맥을 더 잘 이해할 수 있으며 다른 문제는 신경쓰지 않아도 된다.
- 관련 리팩토링
  - 단계 쪼개기 (Split Phase)
    - 서로 다른 일을 하는 코드를 각기 다른 모듈로 분리한다.
    - 서로 다른 데이터를 사용한다면 단계를 나누는데 있어 중요한 단서가 될 수 있다.
  - 함수 이동 (Move Function)
    - 모듈화가 잘 된 소프트웨어는 최소한의 지식만으로 프로그램을 변경할 수 있다.
    - 관련있는 함수나 필드가 모여있어야 더 쉽게 찾고 이해할 수 있다.
    - 함수가 다른 문맥 (클래스)에 있는 데이터 (필드)를 더 많이 참조하는 경우, 함수를 옮기는 것을 고려해 볼 수 있다.
  - 클래스 추출 (Extract Class)
    - 클래스가 다루는 책임(Responsibility)이 많아질수록 클래스가 점차 커진다.
    - 클래스를 쪼개는 기준
      - 데이터나 메서드 중 일부가 매우 밀접한 관련이 있는 경우
      - 일부 데이터가 대부분 같이 바뀌는 경우

### 냄새 8. 산탄총 수술
- 개요
  - 어떤 한 변경 사항이 생겼을 때 여러 모듈을 (여러 함수 또는 여러 클래스를) 수정해야 하는 상황.
  - ex. 새로운 결제 방식을 도입하려면 여러 클래스의 코드를 수정해야 한다.
- 관련 리팩토링
  - 필드 옮기기 (Move Field)
    - 필드를 옮기는 단서
      - 어떤 데이터를 항상 어떤 레코드와 함께 전달하는 경우
      - 어떤 레코드를 변경할 때 다른 레코드에 있는 필드를 변경해야 하는 경우
      - 여러 레코드에 동일한 필드를 수정해야 하는 경우
  - 함수 인라인 (Inline Function)
    - 함수 본문이 함수 이름 만큼 또는 그보다 더 잘 의도를 표현하는 경우도 있다.
      - '함수 추출하기 (Extract Function)'의 반대되는 개념
    - 단순히 메서드 호출을 감싸는 우회형 (indirection) 메서드라면 인라인으로 없앨 수 있다.
  - 클래스 인라인 (Inline Class)
    - 관련 리팩토링을 하는 중에 클래스의 책임을 옮기다보면 클래스의 존재 이유가 빈약해지는 경우가 발생할 수 있다.
    - 빈약해진 클래스의 남은 기능을 적절히 다른 클래스로 보낼 수 있다면, 더 이상 기능이 없는 클래스를 삭제하여 클래스 파일을 효율적으로 관리할 수 있다.

### 냄새 9. 기능 편애
- 개요
  - 어떤 모듈에 있는 함수가 다른 모듈에 있는 데이터나 함수를 더 많이 참조하는 경우에 발생.
- 관련 리팩토링
  - 함수 옮기기 (Move Function)
  - 함수 추출하기 (Extract Function)

### 냄새 10. 데이터 뭉치
- 개요
  - 항상 뭉쳐 다이는 데이터는 한 곳으로 모아두는 것이 좋다.
- 관련 리팩토링
  - 클래스 추출하기 (Extract Class)
  - 매개변수 객체 만들기 (Introduce Parameter Object)
  - 객체 통째로 넘기기 (Preserve Whole Object)

### 냄새 11. 기본형 집착
- 개요
  - 애플리케이션이 다루고 있는 도메인에 필요한 기본 타입을 만들지 않고 프로그래밍 언어가 제공하는 기본 타입을 사용하는 경우가 많다.
  - 기본형으로는 단위 (인치 vs 미터) 또는 표기법을 표현하기 어렵다.
- 관련 리팩토링
  - 기본형을 객체로 바꾸기 (Replace Primitive with Object)
    - 개발 초기에는 기본형 (숫자 또는 문자열)으로 표현한 데이터가 나중에는 해당 데이터와 관련있는 다양한 기능을 필요로 하는 경우가 발생한다.
      - ex) 문자열로 표현하던 전화번호의 지역 코드가 필요하거나 다양한 포맷을 지원하는 경우
      - ex) 숫자로 표현하던 온도의 단위 (화씨, 섭씨)를 변환하는 경우
    - 기본형을 사용한 데이터를 감싸 줄 클래스를 만들면, 필요한 기능을 추가할 수 있다.
  - 타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)
    - 조건문을 다형성으로 표현할 수 있을 때, 서브클래스를 만들고 '조건부 로직을 다형성으로 바꾸기'를 적용한다.
      - 단순 string, int 타입을 통해 조건을 분기하여 각기 다른 로직이 실행되도록 하는 것보다 subclass 형태로 만드는 것이 가독성과 이해도를 높일 수 있다.
  - 조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)
    - 복잡한 조건식을 상속과 다형성을 사용해 코드를 보다 명확하게 분리할 수 있다.
    - switch 문을 사용해서 타입에 따라 각기 다른 로직을 사용하는 코드에 적용할 수 있다.

### 냄새 12. 반복되는 switch
- 개요
  - 반복해서 동일한 switch 문이 존재할 경우, 새로운 조건을 추가하거나 기존의 조건을 변경할 때 모든 switch 문을 찾아서 코드를 고쳐야 할지도 모른다.

### 냄새 13. 반복문
- 개요
  - 프로그래밍 언어 초기부터 있었던 반복문은 처음엔 별다른 대안이 없어서 간과했지만 최근 Java와 같은 언어에서 함수형 프로그래밍을 지원하면서 반복문에 비해 더 나은 대안책이 생겼다.
- 관련 리팩토링
  - 반복문을 파이프라인으로 바꾸기 (Replace Loop with Pipeline)
    - 고전적인 반복문을 파이프라인 오퍼레이션을 사용해 표현하면 코드를 더 명확하게 만들 수 있다.

### 냄새 14. 성의없는 요소
- 개요
  - 예상하고 만들어 놓은 요소들이 기대에 부응하지 못하는 경우가 있는데 그런 경우에 해당 요소들을 제거해야 한다.
    - 나중에 발생할 변화를 미리 대비하는 경우
    - 해당 함수 또는 클래스를 재사용 하는 곳이 있을 것이라 생각하고 만든 경우
- 관련 리팩토링
  - 함수 인라인
  - 클래스 인라인
  - 계층 합치기 (Collapse Hierarchy)
    - 상속 구조를 리팩토링하는 중에 기능을 올리고 내리다 보면 하위클래스와 상위클래스 코드에 차이가 없는 경우가 발생할 수 있다. 그런 경우에 그 둘을 합칠 수 있다.

### 냄새 15. 추측성 일반화
- 개요
  - 나중에 이러 저러한 기능이 생길 것으로 예상하여, 여러 경우에 필요로 할만한 기능을 만들어 놨지만 결국에 쓰이지 않는 코드가 발생한 경우.
- 관련 리팩토링
  - 죽은 코드 제거 (Remove Dead Code)
    - 사용하지 않는 코드가 애플리케이션 성능이나 기능에 영향을 끼치지는 않는다.
    - 하지만, 해당 소프트웨어가 어떻게 동작하는지 이해하려는 사람들에게는 꽤 고통을 줄 수 있다.
    - 실제로 나중에 필요해질 코드라 하더라도 지금 쓰이지 않는 코드라면 (주석으로 감싸는게 아니라) 삭제해야 한다.
      - 나중에 정말로 다시 필요해진다면 git과 같은 버전 관리 시스템을 사용해 복원할 수 있다.

### 냄새 16. 임시 필드
- 개요
  - 클래스에 있는 어떤 필드가 특정한 경우에만 값을 갖는 경우
  - 어떤 객체의 필드가 “특정한 경우에만” 값을 가진다는 것을 이해하는 것은 일반적으로 예상하지 못하기 때문에 이해하기 어렵다.
- 관련 리팩토링
  - 특이 케이스 추가 (Introduce Special Case)
    - 어떤 필드의 특정한 값에 따라 동일하게 동작하는 코드가 반복적으로 나타난다면, 해당 필드를 감싸는 '특별한 케이스'를 만들어 해당 조건을 표현할 수 있다.
 
### 냄새 17. 메시지 체인
- 개요
  - 레퍼런스를 따라 계속해서 메서드 호출이 이어지는 코드.
  - 해당 코드의 클라이언트가 코드 체인을 모두 이해해야 한다.
  - 체인 중 일부가 변경된다면 클라이언트의 코드도 변경해야 한다.
- 관련 리팩토링
  - 위임 숨기기 (Hide Delegate)
    - 캡슐화 (Encapsulation)를 사용하면, 필드 뿐만 아니라 메서드를 숨길 수도 있다.
    - 메서드 호출을 숨겨 메시지 체인을 감출 수 있다.
      - ex) person.department().manager(); -> person.getManager()

### 냄새 18. 중재자
- 개요
  - 캡슐화를 통해 내부의 구체적인 정보를 최대한 감출 수 있다.
  - 그러나, 어떤 클래스의 메서드가 대부분 다른 클래스로 메서드 호출을 위임하고 있다면 중재자를 제거하고 클라이언트가 해당 클래스를 직접 사용하도록 코드를 개선할 수 있다.
- 관련 리팩토링
  - 중재자 제거하기 (Remove Middle Man)
    - 필요한 캡슐화의 정도는 시간에 따라 그리고 상황에 따라 바뀔 수 있다.
    - 위임하고 있는 객체를 클라이언트가 사용할 수 있도록 getter를 제공하고, 클라이언트는 메시지 체인을 사용하도록 코드를 고친 뒤에 캡슐화에 사용했던 메서드를 제거한다.
  - 슈퍼클래스를 위임으로 바꾸기 (Replace Superclass with Delegate)
    - 객체지향에서 '상속'은 기존의 기능을 재사용하는 쉬우면서 강력한 방법이지만 때로는 적절하지 않은 경우도 있다.
    - 또한 아래와 같은 단점도 존재한다.
      - 서브클래스는 슈퍼클래스의 변경에 취약하다.    
      - 서브클래스는 슈퍼클래스의 모든 기능을 지원해야 한다.
  - 서브클래스를 위임으로 바꾸기 (Replace Subclass with Delegate)
    - 대부분의 프로그래밍 언어에서 상속은 오직 한번만 사용할 수 있다.
      - 만약에 어떤 객체를 두가지 이상의 카테고리로 구분해야 한다면?
      - 위임을 사용하면 얼마든지 여러가지 이유로 여러 다른 객체로 위임을 할 수 있다.
    - 슈퍼클래스가 바뀌면 모든 서브클래스에 영향을 줄 수 있다. 따라서 슈퍼클래스를 변경할 때 서브클래스까지 신경써야 한다.
      - 만약에 서브클래스가 전혀 다른 모듈에 있다면?
      - 위임을 사용한다면 중간에 인터페이스를 만들어 의존성을 줄일 수 있다.

### 냄새 19. 내부자 거래
- 개요
  - 어떤 모듈이 다른 모듈의 내부 정보를 지나치게 많이 알고 있는 코드 냄새.
  - 그로인해 지나치게 강한 결합도(coupling)가 생길 수 있다.
- 관련 리팩토링
  - 함수 옮기기 (Move Function) / 필드 옮기기 (Move Field)
  - 위임 숨기기 (Hide Delegate)
  - 슈퍼클래스 또는 서브클래스를 위임으로 교체하기

### 냄새 20. 거대한 클래스
- 개요
  - 어떤 클래스가 너무 많은 일을 하다보면 필드도 많아지고 중복 코드도 보이기 시작한다.
  - 클라이언트가 해당 클래스가 제공하는 기능 중에 일부만 사용한다면 각각의 세부 기능을 별도의 클래스로 분리할 수 있다.
- 관련 리팩토링
  - 슈퍼클래스 추출하기 (Extract Superclass)
    - 두개의 클래스에서 비슷한 것들이 보인다면 상속을 적용하고, 슈퍼클래스로 '필드 올리기 (Pull Up Field)'와 '메서드 올리기 (Pull Up Method)'를 사용한다.
    - 대안으로는 '클래스 추출하기 (Extract Class)'를 적용해 위임을 사용할 수 있다.
