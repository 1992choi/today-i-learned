# MSA
- Inflearn > 카카오 면접관(개발자)이 알려주는 MSA 관점에서의 분산 트랜잭션 패턴



<br><br>



## 개념 정리
### SAGA 패턴이란?
- 여러 트랜잭션을 하나로 묶지 않고, 각각의 로컬 트랜잭션과 보상 트랜잭션으로 처리하는 방식
- SAGA는 최종적 일관성이라는 개념을 가지고 있다.
  - 어느정도 여유를 두고 데이터의 일관성을 유지하는 형태

### SAGA의 3가지 핵심 특징
- 최종적 일관성 (Eventual Consistency)
  - 일시적 불일치 허용
  - 시간이 지나면 일관성 도달 (어느정도 여유를 두고 데이터의 일관성을 유지하는 형태)
- 보상을 통한 롤백 (Compensating Transaction)
  - 논리적 취소
  - 역방향 비즈니스 로직
- 분산된 제어 (Orchestration / Choreography)
  - 중앙 조정자 방식
  - 자율 분산 방식

### 분산 트랜잭션의 문제
- 모놀리식 아키텍처
  - 모놀리식 아키텍처에서는 단일 데이터베이스를 사용하기 때문에 트랜잭션 관리가 용이하였다.
  - 하지만 마이크로서비스 아키텍처에서는 각각의 로컬DB를 사용하기 때문에 분산 트랜잭션 처리가 필요하다.
- MSA 환경에서의 분산 트랜잭션
  - 문제점
    - 원자성을 보장해야 했다.
    - 일관성의 문제도 존재했다.
    - 격리성 문제도 존재한다.
  - 2PC
    - 위의 문제점을 해결하기 위하여 2PC라는 패턴도 사용할 수 있으나, 아래와 같은 문제점이 발생하였다.
      - 성능 저하 문제
      - 가용성 문제
      - 확장성 제약
  - SAGA 패턴
    - 위와 같은 문제점을 보완하기 위해서 SAGA 패턴이 등장하였다.

### 현대적 분산 트랜잭션에서 SAGA
- 분산 트랜잭션의 특징상 물리적 롤백은 불가능하기 때문에 논리적 롤백처리를 한다.
  - 이를 위하여 보상 트랜잭션이 존재한다.
    - 보상 트랜잭션 : 이미 완료된 로컬 트랜잭션의 효과를 논리적으로 취소하는 역할을 수행
    - 보상 트랜잭션은 반드시 역순으로 실행이 되어야한다. (이유는 아래와 같다)
      - 각 로컬 트랜잭션은 이전 단계의 결과에 의존
      - 마지막에 수행된 작업부터 취소해야 의존성 문제가 발생하지 않음
      - 트랜잭션 흐름은 스택(LIFO) 구조와 동일

### 현대적인 SAGA 패턴 vs 전통의 ACID
- ACID란? 
  - A (원자성) : 트랜잭션의 모든 작업이 성공하하거나 실패해야 한다. 
  - C (일관성) : 트랜잭션이 완료가 된다면 일관된 상태여야 한다.
  - I (격리성) : 동시에 실행되는 트랜잭션은 서로 영향을 주지 않는다.
  - D (지속성) : 트랜잭션이 커밋되면, 그 결과는 영구적으로 보존된다.
- 현대적인 SAGA 패턴에서의 관점
  - 분산 트랜잭션의 관점에서 ACID를 유지하는 형태의 트랜잭션을 서비스마다 공유하는것은 불가능하다.
    - 즉, 물리적인 롤백이 불가능하므로 논리적 롤백을 통해 ACID를 흉내내야 한다.
- 격리성 관련
  - 전통의 ACID에서는 트랜잭션의 중간 상태를 볼 수가 없다.
    - 구현에 따라서 Dirty Read가 발생하지 않도록 구현할 수 있음.
  - 하지만 SAGA 패턴의 경우, 보상 트랜잭션이 완료되지 않아 논리적 롤백이 모두 완료되지 않으면 시점에 따라 데이터 불일치가 발생할 수 있다.
    - ex. `A 사용자` : 주문 -> 재고차감 -> 결제 실패 -> (`B 사용자`가 데이터를 조회하는 시점) -> 재고 관련 보상 트랜잭션
      - A 사용자가 10개 중 1개를 주문하였는데 실패. 하지만 B사용자가 조회하는 시점에는 A 사용자의 보상 트랜잭션이 적용되기 전이라 9개로 보임
    - 이를 보완하기 위하여 재고 테이블에 수량만 관리하는 것이 컬럼을 추가하여 우회하여 사용할 수도 있다.
      - ```
        -- 재고 직접 차감 대신
         UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 456;
         
         -- 예약 상태로 표시
         UPDATE inventory SET quantity = quantity - 1, reserved = reserved + 1 
         WHERE product_id = 456;
         
         -- 조회 시 available quantity 계산
         SELECT quantity - reserved AS available 
         FROM inventory WHERE product_id = 456;
        ```