# MSA
- Inflearn > 카카오 면접관(개발자)이 알려주는 MSA 관점에서의 분산 트랜잭션 패턴

<br><br>

### SAGA 패턴이란?
- 여러 트랜잭션을 하나로 묶지 않고, 각각의 로컬 트랜잭션과 보상 트랜잭션으로 처리하는 방식
- SAGA는 최종적 일관성이라는 개념을 가지고 있다.
  - 어느정도 여유를 두고 데이터의 일관성을 유지하는 형태

### SAGA의 3가지 핵심 특징
- 최종적 일관성 (Eventual Consistency)
  - 일시적 불일치 허용
  - 시간이 지나면 일관성 도달 (어느정도 여유를 두고 데이터의 일관성을 유지하는 형태)
- 보상을 통한 롤백 (Compensating Transaction)
  - 논리적 취소
  - 역방향 비즈니스 로직
- 분산된 제어 (Orchestration / Choreography)
  - 중앙 조정자 방식
  - 자율 분산 방식

### 분산 트랜잭션의 문제
- 모놀리식 아키텍처
  - 모놀리식 아키텍처에서는 단일 데이터베이스를 사용하기 때문에 트랜잭션 관리가 용이하였다.
  - 하지만 마이크로서비스 아키텍처에서는 각각의 로컬DB를 사용하기 때문에 분산 트랜잭션 처리가 필요하다.
- MSA 환경에서의 분산 트랜잭션
  - 문제점
    - 원자성을 보장해야 했다.
    - 일관성의 문제도 존재했다.
    - 격리성 문제도 존재한다.
  - 2PC
    - 위의 문제점을 해결하기 위하여 2PC라는 패턴도 사용할 수 있으나, 아래와 같은 문제점이 발생하였다.
      - 성능 저하 문제
      - 가용성 문제
      - 확장성 제약
  - SAGA 패턴
    - 위와 같은 문제점을 보완하기 위해서 SAGA 패턴이 등장하였다.

### 현대적 분산 트랜잭션에서 SAGA
- 분산 트랜잭션의 특징상 물리적 롤백은 불가능하기 때문에 논리적 롤백처리를 한다.
  - 이를 위하여 보상 트랜잭션이 존재한다.
    - 보상 트랜잭션 : 이미 완료된 로컬 트랜잭션의 효과를 논리적으로 취소하는 역할을 수행
    - 보상 트랜잭션은 반드시 역순으로 실행이 되어야한다. (이유는 아래와 같다)
      - 각 로컬 트랜잭션은 이전 단계의 결과에 의존
      - 마지막에 수행된 작업부터 취소해야 의존성 문제가 발생하지 않음
      - 트랜잭션 흐름은 스택(LIFO) 구조와 동일

### 현대적인 SAGA 패턴 vs 전통의 ACID
- ACID란? 
  - A (원자성) : 트랜잭션의 모든 작업이 성공하하거나 실패해야 한다. 
  - C (일관성) : 트랜잭션이 완료가 된다면 일관된 상태여야 한다.
  - I (격리성) : 동시에 실행되는 트랜잭션은 서로 영향을 주지 않는다.
  - D (지속성) : 트랜잭션이 커밋되면, 그 결과는 영구적으로 보존된다.
- 현대적인 SAGA 패턴에서의 관점
  - 분산 트랜잭션의 관점에서 ACID를 유지하는 형태의 트랜잭션을 서비스마다 공유하는것은 불가능하다.
    - 즉, 물리적인 롤백이 불가능하므로 논리적 롤백을 통해 ACID를 흉내내야 한다.
- 격리성 관련
  - 전통의 ACID에서는 트랜잭션의 중간 상태를 볼 수가 없다.
    - 구현에 따라서 Dirty Read가 발생하지 않도록 구현할 수 있음.
  - 하지만 SAGA 패턴의 경우, 보상 트랜잭션이 완료되지 않아 논리적 롤백이 모두 완료되지 않으면 시점에 따라 데이터 불일치가 발생할 수 있다.
    - ex. `A 사용자` : 주문 -> 재고차감 -> 결제 실패 -> (`B 사용자`가 데이터를 조회하는 시점) -> 재고 관련 보상 트랜잭션
      - A 사용자가 10개 중 1개를 주문하였는데 실패. 하지만 B사용자가 조회하는 시점에는 A 사용자의 보상 트랜잭션이 적용되기 전이라 9개로 보임
    - 이를 보완하기 위하여 재고 테이블에 수량만 관리하는 것이 컬럼을 추가하여 우회하여 사용할 수도 있다.
      - ```
        -- 재고 직접 차감 대신
         UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 456;
         
         -- 예약 상태로 표시
         UPDATE inventory SET quantity = quantity - 1, reserved = reserved + 1 
         WHERE product_id = 456;
         
         -- 조회 시 available quantity 계산
         SELECT quantity - reserved AS available 
         FROM inventory WHERE product_id = 456;
        ```
        
### Choreography vs Orchestration 
- Choreography
  - 정의
    - 중앙의 지휘자 없이 각 서비스가 이벤트를 기반으로 자율적으로 동작하는 패턴
  - 장단점
    - 느슨한 결합
      - 서비스 간 직접적인 의존성이 낮음
      - 개별 서비스 장애가 전체 시스템에 즉각적인 영향을 주지 않음
      - 새로운 서비스 추가 및 변경에 유리
    - 확장성과 유연성
      - 중앙 조정자가 없어 특정 컴포넌트 장애로 전체가 멈추는 구조를 피할 수 있음
      - 트래픽 증가 시 서비스 단위로 독립적인 확장 가능
      - 메시지 기반(Event-driven) 아키텍처와 잘 어울림
    - 복잡한 흐름 추적
      - 서비스 수가 많아질수록 이벤트 흐름 파악이 어려움
      - 전체 SAGA 진행 상태를 한눈에 보기 힘듦
    - 순환 의존성 위험
      - 서비스들이 서로 이벤트를 주고받으며 순환 구조가 될 수 있음
      - 잘못 설계되면 이벤트가 반복적으로 발생하는 문제 발생 가능
    - 디버깅 및 장애 분석 난이도 증가
      - 장애 발생 시 어느 서비스에서 문제가 시작되었는지 추적이 어려움

- Orchestration
  - 정의
    - 중앙 조정자(Orchestrator)가 전체 SAGA 흐름과 상태를 관리하는 패턴
  - 장단점
    - 명확한 제어 흐름
      - 트랜잭션 단계와 실행 순서를 중앙에서 관리
      - 전체 비즈니스 흐름 파악이 쉬움
    - 모니터링 및 상태 관리 용이
      - SAGA 진행 상태를 중앙에서 확인 가능
      - 장애 발생 시 문제 지점을 빠르게 파악할 수 있음
    - 복잡한 로직 처리에 유리
      - 조건 분기, 예외 처리, 보상 트랜잭션 관리가 비교적 단순
    - 단일 장애 지점(SPOF) 가능성
      - Orchestrator 장애 시 전체 SAGA 흐름이 중단될 수 있음
      - 중앙 컴포넌트에 문제가 발생하면 여러 서비스가 정상이어도 트랜잭션이 진행되지 않음
    - 확장성 한계
      - 모든 흐름이 Orchestrator를 거치므로 트래픽 증가 시 병목이 발생할 수 있음

### SAGA 패턴 이외의 패턴
- TCC (Try–Confirm–Cancel)
  - 개념
    - 자원을 먼저 예약(Try)한 뒤, 최종 확정(Confirm) 또는 취소(Cancel)하는 방식의 분산 트랜잭션 패턴
    - SAGA의 최종적 일관성으로 인한 격리성 문제를 보완하기 위해 등장
    - 중앙 조정자(Coordinator)를 통해 전체 트랜잭션 흐름을 관리
  - 특징
    - 트랜잭션 경계가 명확
      - Try 단계에서 자원을 선점하여 중간 상태 노출을 최소화
    - 격리성 보장이 비교적 우수
      - 다른 트랜잭션이 중간 상태의 데이터를 사용하는 문제를 줄일 수 있음
    - SAGA 대비 강한 제어 흐름
      - Confirm / Cancel 단계가 명시적으로 구분됨
  - 한계점
    - 구현 난이도가 매우 높음
      - 모든 서비스가 Try / Confirm / Cancel 인터페이스를 제공해야 함
    - 상태 관리 복잡
      - 예약 상태, 확정 상태, 취소 상태를 모두 관리해야 함
    - 중앙 조정자 존재로 인한 병목 가능성
      - Coordinator가 트랜잭션 흐름의 핵심이 됨
    - 기존 시스템에 적용하기 어려움
      - 레거시 서비스 구조 변경 비용이 큼
- 3PC (Three-Phase Commit)
  - 개념
    - 분산 시스템에서 여러 노드 간 트랜잭션 일관성을 보장하기 위한 커밋 프로토콜
    - 2PC(Two-Phase Commit)의 단점을 보완하기 위해 설계됨
  - 2PC의 한계로 인해 등장
    - 2PC는 Coordinator 장애 시 참여 노드들이 대기 상태에 빠질 수 있음
    - 네트워크 분리 상황에서 블로킹 문제가 발생
  - 특징
    - Prepare → Pre-Commit → Commit 의 3단계로 구성
    - 참여 노드들이 무한 대기에 빠지는 상황을 줄이기 위한 단계 추가
    - 2PC보다 안전성 향상
  - 한계점
    - 네트워크 지연과 장애를 완전히 해결하지는 못함
    - 단계 증가로 인한 성능 저하
    - 구현 복잡도 증가
    - 여전히 강한 동기 통신에 의존
    - MSA 환경에서는 가용성과 확장성 측면에서 부적합

### 실습코드
- 실습코드는 별도 Repo로 만들지 않음.
  - 강의 내 첨부파일로 확인가능
