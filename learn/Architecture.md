# Architecture
- Fast Campus > 조대협의 대용량 아키텍처 설계 로드맵

<br><br><br>

# 정리
### 백엔드 시스템 아키텍처
- 가장 기본적인 아키텍처 구성 (API 서버 + 캐시 서버 + 데이터베이스)
  - API 서버
    - 다양한 프로그래밍 언어로 API 서버를 구축할 수 있다.
      - Java (Spring Boot)
      - Node.js (Express,Next.js)
      - GoLang
      - RubyOnRails
      - Python (Django,Flask,FastAPI)
    - 서버는 아래와 같은 런타임 환경 또는 배포 방식으로 구성할 수 있다.
      - VM (GCE, EC2)
      - Container + VM
      - Serverless
      - Kubernetes
      - Firebase hosting
    - API 서버 인프라 설계 시 아래와 같은 항목을 고려해야한다.
      - 로드 밸런서 관련 
        - L4/L7 로드 밸런서: 트래픽 분산 계층 구분 
        - 소프트웨어 로드밸런서: nginx, haproxy, envoy 등 직접 설치해서 운영하는 방식 
        - 웹캐시: CDN이나 Reverse Proxy를 이용한 캐싱 
        - API 게이트웨이 고려: 인증, 라우팅, 속도 제한 등 API 관리 
        - 네트워크 (ADN) 고려: Application Delivery Network, 고성능/저지연 전송망 활용 
      - 보안 요소 
        - WAF (웹 방화벽): 웹 공격 방어 (SQL Injection, XSS 등)
      - 비용 최적화 요소 
        - Spot VM 활용: 유휴 자원을 저렴하게 빌리는 방식 
        - API 서버가 Stateless하다는 특징 덕분에, Spot VM이 중간에 종료되더라도 서비스에 큰 문제 없이 재시작 가능 
        - 일반 VM + Spot VM 혼용으로 비용 절감 (Spot VM은 중간에 종료되는 케이스가 있기 때문에 모두 Spot VM으로 구성한다면, 큰 장애로 이어질 수 있다.)
  - 캐시 서버
    - 캐시서버의 대표적인 예
      - Memcached 
        - 단순 Key-Value 스토어 형태의 인메모리 캐시 서버 
        - 문자열 데이터만 저장 가능, 구조가 단순하고 속도가 빠름 
        - 주로 세션 저장, 간단한 데이터 캐싱에 사용 
      - Redis 
        - 인메모리 데이터 저장소이지만, Memcached보다 다양한 데이터 타입 지원 
        - 문자열, 리스트, 셋, 해시, 정렬된 셋(Sorted Set) 등 구조화된 데이터 저장 가능 
        - 퍼시스턴스(데이터 영속화) 지원, Pub/Sub 기능 등 부가 기능 풍부
    - 캐싱 기법
      - TTL
        - 데이터를 캐시에 저장할때 일정 시간이 지나면 캐시에서 데이터를 삭제함
        - 장점 : 실시간성이 덜 중요한 데이터에 적합하며, 캐시 오버플로우 방지
        - 단점 : 데이터가 업데이트 되었을때, 캐시 데이터와 불일치가 발생할 수 있음.
      - Lazy Loading
        - 데이터를 캐시에서 조회했을때, 없을 경우 데이터베이스에서 캐시로 데이터를 로딩
        - 장점 : 자주 사용되는 데이터만 캐시에 남음
        - 단점 : 처음 요청에는 반드시 DB에 접근해야 하기 때문에, 캐시 미스율이 높음
      - Write through caching
        - 데이터 변경시, 캐시에 먼저 반영하고 데이터베이스에 변경 내용을 반영
        - 장점 : 캐시와 데이터베이스의 내용이 일관됨
        - 단점 : 데이터 변경 작업이 많을 경우, 캐시 업데이트가 많기 때문에 성능 저하 가능성이 있음
      - Write back
        - 캐시에 먼저 데이터를 기록하고, 일정 시간후에, DB에 저장하는 방식
        - 장점 : 쓰기 작업이 매우 빠름
        - 단점 : 데이터의 불일치가 발생, 장애 발생시 캐시의 데이터가 유실될 수 있음
  - 데이터베이스
    - 종류
      - RDBMS
        - 테이블간의 관계가 있는 경우 유용.
        - 가장 범용적으로 사용됨
        - 일관성 보장이 됨 (중요한 트랜잭션에 유용)
      - NoSQL
        - 단순하지만 대용량 데이터에 유리
        - 일관성 보장이 안될 수 있음
        - 비정형 데이터 (JSON 등) 지원 가능
    - RDBMS의 종류와 특징
      - 오라클
        - 가격은 높으나 가장 높은 성능과,안정성,확장성 제공
        - RAC를 이용한 Active-Active 구성 가능
        - 엑사데이터 (하드웨어 어플라이언스)를 통한 높은 성능 제공
      - MSSQL
        - 중간 가격대로, 가성비가 좋음
        - 게이밍이나 중소 규모 워크로드에 많이 사용된다.
      - Postgres
        - 엔터프라이즈 수준의 기능 (2PC 등)을 지원
        - Vector store, GIS 기능등 다양한 기능을 지원
      - MySQL
        - OLTP(=일반적인 트랜잭션 CRUD에 최적화된 설정)에 최적화되어 있으며, 높은 성능
        - 사용이 편리하다.
    - RDBMS 고가용성 및 스케일링 구조
      - Active Stand by 구조
        - 고가용성 (High Availability)를 지원하기 위한 구조로, Active(Master)노드가 다운 되었을때 Stand by 노드가 마스터 노드로 격상되어서 서비스를 정상적으로 제공함
        - 사용하지 않는 Standby 노드를 하나 항상 유지해야 함.
      - Active Active 구조
        - 고가용성과 확장성을 동시에 구현하는 구조로, 여러개의 노드에 동시 쓰기, 업데이트, 삭제, 읽기가 가능함
        - 노드간에 트렌젝션을 일관성있게 계속 복제해야 하기 때문에 구현이 어려움
        - Oracle RAC, MySQL Galera Cluster 등과 같은 추가 솔루션이 필요함
      - Master Slave 구조
        - 확장성을 지원하기 위한 구조로 Master 노드에는 쓰기,업데이트 등만 하고, Read Replica(Slave)노드에는 읽기만 함
    - 데이터 베이스 샤딩
      - 데이터의 전체 양이 방대하여 단일 데이터베이스에 저장하기 어려운 경우, 데이터를 분리된 데이터베이스에 저장할 수 있다.
      - 방식
        - Vertical sharding
        - Horizontal sharding
    - NoSQL
      - Not Only SQL
      - RDBMS와 다르게 SQL을 사용하지 않는 DBMS의 총칭
      - 주로 대규모 데이터와 빠른 읽기 쓰기
      - 분류
        - KV 스토어
          - 키에 대한 밸류를 저장하는 형태
          - 소팅된 키를 사용하는 경우가 많음
          - put/get, 커서 이동 정도의 쿼리만 지원 (Join,sorting, where 등은 지원하지 않음)
          - 주요 제품군에는 HBase, Cassandra, Google Cloud BigTable, AWS Dynamo가 있다.
        - 도큐먼트 DB
          - JSON 문서를 통으로 저장 가능
          - Where, join 등 복잡한 쿼리를 일부 지원
          - 주요 제품군에는 MongoDB, Google FireStore가 있다.
        - 그래프 DB
          - 그래프 구조의 데이터 베이스
          - 노드와 엣지를 통해서 관계를 표현하는데 강함
          - 주요 제품군에는 Neo4J, AWS neptune가 있다.
- 비동기 아키텍처
  - 메세지 큐를 기반으로 비동기 처리를하는 아키텍처를 구성할 수 있다.
    - MQ, RABBIT MQ, KAFKA, SQS 등이 존재.
    - 응답을 기다리지 않고 바로 리턴
    - 큐 뒤에 다수의 구독자가 메세지를 읽어서 처리
      - 구독자수를 조정하여 대용량 처리가 용이
  - 비동기 처리 메시지 패턴
    - FIRE & FORGET
      - 메시지를 보내고 응답을 기다리지 않는 방식
      - 기본적으로 비동기 메시지라면 발송자는 기다리지 않으므로 Fire & Forget 성격이 있다.
    - PUBLISH & SUBSCRIBE
      - 하나의 메시지를 여러 구독자에게 전달하는 방식
      - 하나의 메시지를 한 구독자가 받았다고 사라지지 않는다. (이로인해 같은 메시지를 다수의 구독자가 전달받을 수 있음)
    - ROUTING
      - 메시지의 라우팅 키나 조건에 따라 특정 큐 또는 소비자에게만 메시지를 전달
  - 메시지큐의 종류와 특징
    - 확장 가능한 분산큐
      - Kafka
      - Google Pub/Sub
      - Active MQ
    - 확장이 불가능한 큐 (메시지큐들은 대부분 메모리에 메시지를 저장한다. 이러한 특징 때문에 확장 불가능 큐의 경우 큐가 다 차면 OOM으로 죽는 경우가 많다.)
      - Redis
      - Rabbit MQ
      - IBM MQ
    - XA(분산 트랜잭션) 지원
      - JMS
      - Active MQ
      - Redis
    - 가장 일반적으로 사용되는 큐
      - Kafka
      - Rabbit MQ
  - 디자인시 주의사항
    - 순차 보장이 필요한 경우
      - 메시지를 동일한 큐로 보내고, 단일 소비자를 사용하는 방식으로 처리
    - 메시지 중복 처리
      - 메시지 ID를 기반으로 Consumer에서 기록을 유지해서 비교
      - Consumer에서 idempotent를 유지하도록 설계
    - 메시지 유실방지
      - ACK를 사용하여 메시지가 성공 처리되었음을 저장
      - 에러큐를 이용하여, 비정상 메시지에 대한 처리
    - 메시지 크기
      - 메시지는 간결하게 유지 (메시지가 클 경우 성능 저하와 OOM을 유발)
      - 대용량 데이터는 별도의 스토리지에 저장 (NFS,S3 etc)하고 메타 정보만 큐에 저장
    - TTL 설정
      - 메시지큐의 TTL을 적절히 설정
      - 만료된 메시지를 에러큐로 보내거나, 삭제

### 마이크로 서비스 아키텍처
- 마이크로 서비스
  - 시스템을 여러개의 독립된 서비스로 나눠서 구현한후, 이 서비스를 조합함으로써 비즈니스 시나리오를 구현한 아키텍처 디자인 스타일.
- 마이크로 서비스 아키텍처의 특징
  - 분산형 거버넌스 모델
  - 데이터도 분산 (서비스마다 독립적임)
  - 다양한 기술을 혼용해서 사용 가능
  - 장애 격리(Isolation) 가능
  - 부분 독립 배포 가능
- 모노리틱 서비스 / 마이크로 서비스의 장단점
  - 모노리틱 서비스 
    - 장점
      - 단일 기술을 사용하기 때문에 관리통제,유지보수가 용이함.
      - 트랜잭션 관리 등 미션 크리티컬한 업무에 강점이 있음.
    - 단점
      - 다양한 기술 스택을 사용할 수 없음
      - 중앙에서 전체를 통제해야 하기 때문에 커뮤니케이션 비용이 증가함
      - 배포시간이 증가함
  - 마이크로 서비스
    - 장점
      - 용도에 맞는 기술을 섞어쓸 수 있음
      - 각 서비스별로 독립적으로 의사결정, 개발,운영을 하기 때문에 개발속도가 빠름
      - 느슨한 결합으로 특정 서비스만 쉽게 업데이트가 가능
    - 단점
      - 여러 기술 스택을 사용하기 때문에 관리 통제가 어려움
      - 서비스가 많을 경우, 디버깅 모니터링이 어려워짐
- DDD(Domain Driven Design)
  - 등장 배경
    - 기존 객체 지향형 방법론이 기술 중심의 접근 방식으로, 실제 비즈니스 업무 도메인을 효과적으로 반영하지 못한다는 문제에서 시작되었다.
    - 마이크로 서비스의 서비스 분할이라는 개념과 잘 일치되어 널리 사용되기 시작.
  - DDD의 필요성
    - 기존 방식의 문제점
      - 비즈니스 로직의 복잡성이 증가하면서 소프트웨어 설계가 어려워짐.
      - 비즈니스 용어와 개발 용어의 차이로 인해 소통의 오류 발생
    - 장점
      - 비즈니스 중심 설계
        - 비즈니스에 대한 이해를 바탕으로 설계를 진행
      - 의사소통 개선
        - 비즈니스 전문가와 개발자 간의 공통 언어(유비쿼터스 언어)를 사용하여 소통 효율 증대.특히 개발팀의 비즈니스에 대한 이해도가 증가함
      - 유지보수 용이
        - 명확하게 분리된 도메인 모델로 인해 유지보수 및 확장 용이.
    - 단점
      - 높은 학습 비용
        - 복잡한 개념과 규칙을 포함하기 때문에, 초기 학습 비용이 높음
      - 오버 디자인
        - 비즈니스 도메인에 집중하기 때문에, 단순한 애플리케이션 개발의 경우 불필요한 복잡성을 유발함
      - 비즈니스 요구 사항 변경에 대한 어려움
        - 도메인 변경이 많으면 전체 구조가 다 무너짐 (도메인 모델을 유지하기 위함)
      - 구현의 복잡성
        - 도메인 모델을 유지하기 위해서 불필요한 encapsulation 등이 발생할 수 있음.
      - 애자일 방법론과 충돌
        - DDD는 구조적이과 계획적인 접근 방식, 애자일은 빠른 개발속도와 민첩성을 강조.
- API 게이트웨이
  - 기본구조와 기능
    - L7의 기본기능에 추가 기능이 더해진 형태.
    - 외부에서 들어오는 API 호출에 대해서 라우팅,인증,로깅 등의 Intermediary 서비스 개념을 계승함
  - API 게이트웨이의 키 인증 방식
    1. 클라이언트가 API 키를 요청한다.
    2. ID, PASSWORD로 API키를 발급하여 저장한다.
    3. 클라이언트가 API를 호출한다.
    4. API 게이트웨이가 API키를 요청에서 추출하여 키 관리 시스템을 통해서 인증한다.
    5. 인증이 성공한 호출에 대해서 API를 호출한다.
  - 주요 특징
    - 다중 엔드포인트
      - 같은 API 대해서 다른 엔드포인트를 제공한다.
      - 다른 호출 방식(프로토콜 등) 및 IP 등에 따라서 다른 엔드포인트를 제공할 수 있다.
    - 트래픽 컨트롤
      - API Key, APP Key, Header, Path와 같은 Request에 대한 검증을 수행할 수 있다.
      - Rate Limiting
      - IP white listing
      - WAF integration
    - 메시지 변환
      - 입력된 API 메시지에 대해서 변환 작업을 수행한다.
        - XML이나 다른 포맷의 메시지를 JSON이나 다른 포맷으로 변경
    - 라우팅
      - API 요청의 헤더나 본문의 내용에 따라서 백앤드 서비스로 라우팅
    - 오케스트레이션
      - 여러단계의 API 호출을 통하여 하나의 기능을 제공하는 시나리오를 API 게이트웨이에서 구현
      - 복잡도가 높게 증가하기 때문에, 좋은 패턴은 아니다.
    - 모니터링
      - 사용량, 트래픽, 응답시간 등 모니터링이 가능하다.
- 분산 트랜잭션
  - 분산 트랜잭션 방식
    - Comparing Log
      - 각 노드의 로그를 비교하여 데이터 일관성을 검증하는 방식
    - XA(2PC) 
      - 두 단계 커밋(Prepare → Commit)으로 여러 DB 간 트랜잭션을 원자적으로 보장하는 방식
    - Data Rep (CDC)
      - 한 시스템에서 발생한 데이터 변경(Insert, Update, Delete)을 캡처하여 다른 시스템(DB)으로 전달하는 방식
- 서비스 간 트랜잭션 추적
  - 마이크로서비스 구조에서는 여러 서비스가 연쇄적으로 호출되므로 트랜잭션 추적이 어렵다.
  - 트랜잭션 추적을 위해 Transaction ID를 활용할 수 있다.
    - 동일 서비스 내에서는 ThreadLocal을 이용해 트랜잭션 ID를 저장하고 참조 가능하다.
    - 다른 서비스로 전달할 때는 HTTP 헤더를 통해 전파할 수 있다.
  - 직접 구현하기보다 Zipkin, Jaeger와 같은 오픈소스를 활용하면 효율적이다.
- 대규모 마이크로 서비스의 문제점
  - 서비스 위치 파악이 어렵다.
    - 어느 서비스가 존재하는지 확인하기 어렵다.
  - 서비스 간 종속성 및 장애 전파.
    - 한 서비스의 장애가 연쇄적으로 영향을 줄 수 있다.
  - 트랜잭션/요청 추적이 어렵다.
    - 여러 서비스를 호출할 때 호출 흐름과 상태를 파악하기 어렵다.
- 마이크로서비스에서 사용되는 다양한 패턴
  - Request Routing & Traffic Shaping
    - 요청 분산과 트래픽 관리를 통해 부하를 조절한다.
  - Rate Limit
    - 서비스 호출량을 제한하여 과부하를 방지한다.
  - Circuit Breaking
    - 장애 발생 시 호출을 차단하여 전체 장애를 방지한다.
  - Service Authentication
    - 서비스 간 안전한 인증을 제공한다.
  - A/B Rollout / Canary Deployments
    - 점진적 배포를 통해 리스크를 최소화한다.
  - Fault Injections
    - 의도적으로 장애를 발생시켜 시스템 내성을 테스트한다.
  - Failure Management
    - 장애 발생 시 복구 및 대응 전략을 관리한다.
  - Advanced Monitoring and Tracing
    - 성능과 호출 흐름을 모니터링하고 추적한다.
  - Observability & Insight
    - 전체 시스템 상태를 가시화하고 분석한다.

### REST API 설계
- REST의 구성 요소
  - 리소스(Resource)
    - HTTP URI를 이용하여 자원을 정의한다.
  - 동사 (Verb)
    - HTTP Method를 이용하여 자원에 대한 행위를 정의한다.
  - 표현 (representation)
    - HTTP Body를 이용하여 자원에 대한 행위의 내용을 정의한다.
- HTTP 메서드 설계
  - GET
    - 리소스 조회
    - Ex. GET /users (모든 사용자 조회), GET /users/{userId} (특정 사용자 조회)
  - POST
    - 리소스 생성
    - Ex. POST /users (새 사용자 생성)
  - PUT
    - 리소스 전체 수정
    - Ex. PUT /users/{userId} (특정 사용자의 정보 전체 수정)
  - PATCH
    - 리소스 일부 수정
    - Ex. PATCH /users/{userId} (특정 사용자의 일부 정보 수정)
  - DELETE
    - 리소스 삭제
    - Ex. DELETE /users/{userId} (특정 사용자 삭제)
- REST API 설계 원칙
  - 명확한 Resource 식별
    - URI는 계층적 구조를 따르고, 동작이 아닌 리소스 중심으로 설계되어야 한다.
      - /users/{userId}와 같은 계층적 구조
      - /getUser와 같은 동작으로 명명되면 안된다.
  - HTTP 메서드 기반 리소스 조작
    - REST는 HTTP 메서드(GET, POST, PUT, PATCH, DELETE)를 사용하여 리소스를 조작한다.
  - 표준화된 응답 코드 사용
    - REST API는 HTTP 상태 코드를 사용해 요청 결과를 알린다.
      - 실패 케이스에서 200 OK와 함께 오류코드를 전달하는 방식은 잘못된 설계이다.
  - 캐시 가능
    - REST 응답은 캐시 가능 여부를 명시해야 한다.
- REST API 단점
  - De-facto 표준
    - 명시적인 표준이 없다.
    - 관리가 어렵다.
    - 좋은 디자인을 가이드 하기가 어렵다.
  - RESTful 한 설계가 필요
    - RDBMS는 관계형으로 리소스를 표현하지 않기 때문에 REST한 테이블 구조 설계가 필요하다.
      - 그래서 JSON을 그대로 저장하는 도큐먼트 기반의 NoSQL이 잘 맞음
- REST API 설계 가이드
  - 참고용 링크
    - Microsoft REST API design guide :
      - https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design
    - Google REST API design guide
      - https://cloud.google.com/apis/design
  - 리소스는 명사로 표현
    - URI는 동작이나 행동보다는 리소스(대상)를 식별하는 데 초점을 맞춰야 한다. 
    - 명사를 사용하여 리소스를 표현하는 것이 좋다.
    - 올바른 예시) /users, /orders, /products
    - 잘못된 예시) /getUsers, /createOrder, /deleteProduct [안티패턴/터널링]
  - 리소스는 복수형으로 사용
    - 리소스 이름은 일반적으로 복수형을 사용한다.
    - 이는 리소스 컬렉션을 나타내며 RESTful API의 통일성을 높인다.
    - 올바른 예시) /users, /products
    - 잘못된 예시) /user, /product
  - URI 경로는 계층 구조를 반영
    - URI는 리소스 간의 관계를 표현할 수 있어야 하며, 경로는 계층 구조를 따르는 것이 좋다.
    - 예시) /users/{userId}/orders/{orderId}
  - 하이픈(-)과 밑줄(_)
    - 하이픈(-)은 여러 단어로 된 URI를 구분할 때 사용하고, 밑줄(_)은 가독성을 떨어뜨릴 수 있으므로 지양한다.
    - 올바른 예시) /order-items
    - 잘못된 예시) /order_items
- 에러 처리
  - 에러가 발생했을 때는 클라이언트가 원인을 명확히 알 수 있도록 표준화된 에러 메시지 형식을 제공해야 한다.
  - 일반적으로 JSON 형식을 사용한다.
  - Error Stack은 response 메시지에 포함 시키지 않는게 좋다.
    - 어떤 기술 스택을 사용하는지, 파일 위치등 해킹 가능한 자료가 유출될 수 있기 때문
- 버전 관리
  - 버저닝을 통해 다른 버전의 리소스를 응답할 수 있다.
  - 방식은 아래와 크게 아래와 같이 분류할 수 있다.
    - URI에 포함
      - GET /v1/resource
      - 명확하고 직관적, 테스트가 편함
      - REST 디자인 원칙에서 다소 벗어남
      - 가장 일반적인 방식
    - Sub domain에 포함
      - GET https://v1.api.example.com/resource
      - API 서버를 물리적으로 분리하여, 독립 운영 가능
      - DNS, 네트워크 설정 필요
    - Header에 포함
      - GET /resource Headers: Accept:   
        application/vnd.myapi.v1+json
      - 클라이언트 추가 작업이 필요하고, 브라우저에서 테스트하기 어려움
    - Query Parameter에 포함
      - GET /resource?version=1
      - 간단한 버전 관리
      - 캐싱이 복잡해짐