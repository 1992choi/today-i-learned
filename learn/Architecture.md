# Architecture
- Fast Campus > 조대협의 대용량 아키텍처 설계 로드맵

<br><br><br>

# 정리
### 백엔드 시스템 아키텍처
- 가장 기본적인 아키텍처 구성 (API 서버 + 캐시 서버 + 데이터베이스)
  - API 서버
    - 다양한 프로그래밍 언어로 API 서버를 구축할 수 있다.
      - Java (Spring Boot)
      - Node.js (Express,Next.js)
      - GoLang
      - RubyOnRails
      - Python (Django,Flask,FastAPI)
    - 서버는 아래와 같은 런타임 환경 또는 배포 방식으로 구성할 수 있다.
      - VM (GCE, EC2)
      - Container + VM
      - Serverless
      - Kubernetes
      - Firebase hosting
    - API 서버 인프라 설계 시 아래와 같은 항목을 고려해야한다.
      - 로드 밸런서 관련 
        - L4/L7 로드 밸런서: 트래픽 분산 계층 구분 
        - 소프트웨어 로드밸런서: nginx, haproxy, envoy 등 직접 설치해서 운영하는 방식 
        - 웹캐시: CDN이나 Reverse Proxy를 이용한 캐싱 
        - API 게이트웨이 고려: 인증, 라우팅, 속도 제한 등 API 관리 
        - 네트워크 (ADN) 고려: Application Delivery Network, 고성능/저지연 전송망 활용 
      - 보안 요소 
        - WAF (웹 방화벽): 웹 공격 방어 (SQL Injection, XSS 등)
      - 비용 최적화 요소 
        - Spot VM 활용: 유휴 자원을 저렴하게 빌리는 방식 
        - API 서버가 Stateless하다는 특징 덕분에, Spot VM이 중간에 종료되더라도 서비스에 큰 문제 없이 재시작 가능 
        - 일반 VM + Spot VM 혼용으로 비용 절감 (Spot VM은 중간에 종료되는 케이스가 있기 때문에 모두 Spot VM으로 구성한다면, 큰 장애로 이어질 수 있다.)
  - 캐시 서버
    - 캐시서버의 대표적인 예
      - Memcached 
        - 단순 Key-Value 스토어 형태의 인메모리 캐시 서버 
        - 문자열 데이터만 저장 가능, 구조가 단순하고 속도가 빠름 
        - 주로 세션 저장, 간단한 데이터 캐싱에 사용 
      - Redis 
        - 인메모리 데이터 저장소이지만, Memcached보다 다양한 데이터 타입 지원 
        - 문자열, 리스트, 셋, 해시, 정렬된 셋(Sorted Set) 등 구조화된 데이터 저장 가능 
        - 퍼시스턴스(데이터 영속화) 지원, Pub/Sub 기능 등 부가 기능 풍부
    - 캐싱 기법
      - TTL
        - 데이터를 캐시에 저장할때 일정 시간이 지나면 캐시에서 데이터를 삭제함
        - 장점 : 실시간성이 덜 중요한 데이터에 적합하며, 캐시 오버플로우 방지
        - 단점 : 데이터가 업데이트 되었을때, 캐시 데이터와 불일치가 발생할 수 있음.
      - Lazy Loading
        - 데이터를 캐시에서 조회했을때, 없을 경우 데이터베이스에서 캐시로 데이터를 로딩
        - 장점 : 자주 사용되는 데이터만 캐시에 남음
        - 단점 : 처음 요청에는 반드시 DB에 접근해야 하기 때문에, 캐시 미스율이 높음
      - Write through caching
        - 데이터 변경시, 캐시에 먼저 반영하고 데이터베이스에 변경 내용을 반영
        - 장점 : 캐시와 데이터베이스의 내용이 일관됨
        - 단점 : 데이터 변경 작업이 많을 경우, 캐시 업데이트가 많기 때문에 성능 저하 가능성이 있음
      - Write back
        - 캐시에 먼저 데이터를 기록하고, 일정 시간후에, DB에 저장하는 방식
        - 장점 : 쓰기 작업이 매우 빠름
        - 단점 : 데이터의 불일치가 발생, 장애 발생시 캐시의 데이터가 유실될 수 있음
  - 데이터베이스
    - 종류
      - RDBMS
        - 테이블간의 관계가 있는 경우 유용.
        - 가장 범용적으로 사용됨
        - 일관성 보장이 됨 (중요한 트랜잭션에 유용)
      - NoSQL
        - 단순하지만 대용량 데이터에 유리
        - 일관성 보장이 안될 수 있음
        - 비정형 데이터 (JSON 등) 지원 가능
    - RDBMS의 종류와 특징
      - 오라클
        - 가격은 높으나 가장 높은 성능과,안정성,확장성 제공
        - RAC를 이용한 Active-Active 구성 가능
        - 엑사데이터 (하드웨어 어플라이언스)를 통한 높은 성능 제공
      - MSSQL
        - 중간 가격대로, 가성비가 좋음
        - 게이밍이나 중소 규모 워크로드에 많이 사용된다.
      - Postgres
        - 엔터프라이즈 수준의 기능 (2PC 등)을 지원
        - Vector store, GIS 기능등 다양한 기능을 지원
      - MySQL
        - OLTP(=일반적인 트랜잭션 CRUD에 최적화된 설정)에 최적화되어 있으며, 높은 성능
        - 사용이 편리하다.
    - RDBMS 고가용성 및 스케일링 구조
      - Active Stand by 구조
        - 고가용성 (High Availability)를 지원하기 위한 구조로, Active(Master)노드가 다운 되었을때 Stand by 노드가 마스터 노드로 격상되어서 서비스를 정상적으로 제공함
        - 사용하지 않는 Standby 노드를 하나 항상 유지해야 함.
      - Active Active 구조
        - 고가용성과 확장성을 동시에 구현하는 구조로, 여러개의 노드에 동시 쓰기, 업데이트, 삭제, 읽기가 가능함
        - 노드간에 트렌젝션을 일관성있게 계속 복제해야 하기 때문에 구현이 어려움
        - Oracle RAC, MySQL Galera Cluster 등과 같은 추가 솔루션이 필요함
      - Master Slave 구조
        - 확장성을 지원하기 위한 구조로 Master 노드에는 쓰기,업데이트 등만 하고, Read Replica(Slave)노드에는 읽기만 함
    - 데이터 베이스 샤딩
      - 데이터의 전체 양이 방대하여 단일 데이터베이스에 저장하기 어려운 경우, 데이터를 분리된 데이터베이스에 저장할 수 있다.
      - 방식
        - Vertical sharding
        - Horizontal sharding
    - NoSQL
      - Not Only SQL
      - RDBMS와 다르게 SQL을 사용하지 않는 DBMS의 총칭
      - 주로 대규모 데이터와 빠른 읽기 쓰기
      - 분류
        - KV 스토어
          - 키에 대한 밸류를 저장하는 형태
          - 소팅된 키를 사용하는 경우가 많음
          - put/get, 커서 이동 정도의 쿼리만 지원 (Join,sorting, where 등은 지원하지 않음)
          - 주요 제품군에는 HBase, Cassandra, Google Cloud BigTable, AWS Dynamo가 있다.
        - 도큐먼트 DB
          - JSON 문서를 통으로 저장 가능
          - Where, join 등 복잡한 쿼리를 일부 지원
          - 주요 제품군에는 MongoDB, Google FireStore가 있다.
        - 그래프 DB
          - 그래프 구조의 데이터 베이스
          - 노드와 엣지를 통해서 관계를 표현하는데 강함
          - 주요 제품군에는 Neo4J, AWS neptune가 있다.