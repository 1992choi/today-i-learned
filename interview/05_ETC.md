## OSI 7계층과 TCP/IP 4계층
- OSI 7계층과 TCP/IP 4계층
  - ![image](https://github.com/1992choi/today-i-learned/assets/27760576/8f74cf13-703e-43a9-89d2-bd9543525acd)
- OSI 7계층이란?
  - 네트워크 통신이 일어나는 과정을 7단계로 나눈 국제 표준화 기구(ISO)에서 정의한 네트워크 표준 모델이다.
  - 이 모델은 프로토콜을 기능별로 나눈 것이다.
- OSI 7계층 - 계층별 특징
  - 물리 계층(Physical)
    - 전기적, 기계적, 기능적인 특성을 이용하여 통신 케이블로 데이터를 전송한다.
    - 사용되는 통신 단위는 비트(bit)이며, 0또는 1만 나타낼 수 있다.
    - 단지 데이터를 전달만 할 뿐 전송하려는, 또는 받으려는 데이터가 무엇인지는 전혀 신경쓰지 않는다.
    - 대표적인 장치로 통신 케이블, 리피터, 허브 등이 있다.
  - 데이터 링크 계층(Data Link)
    - 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 수행을 도와주는 역할을 한다.
    - 맥 주소(MAC Address)를 가지고 통신한다.
    - 전송되는 단위를 프레임(frame)이라고 하며, 대표적인 장비로는 브리지, 스위치 등이 있다.
  - 네트워크 계층(Network)
    - 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 역할을 한다.
    - 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)을 한다.
    - 대표적인 장비로 라우터, (라우팅 기능이 포함된)스위치가 있으며, IP 주소를 사용한다.
    - 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다.
  - 전송 계층(Transport)
    - 통신을 활성화하기 위한 계층이다. 보통 TCP 프로토콜을 사용하며, 포트를 열어서 응용 프로그램을 전송한다.
    - 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있게 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 한다.
  - 세션 계층(Session)
    - 데이터가 통신하기 위한 논리적인 연결을 한다.
    - 세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능이 있다.
    - 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
    - TCP/IP 세션을 만들고 없애는 책임을 진다.
  - 표현 계층(Presentation)
    - 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화한다.
    - 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로 덜어준다.
    - 해당 데이터가 텍스트인지, 그림인지, GIF인지, JPG인지의 구분 등의 역할을 한다.
  - 응용 계층(Application)
    - 최종 목적지로서 HTTP, FTP, SMTP, Telnet 등과 같은 프로토콜이 있다.
    - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
- TCP/IP 4계층이란?
  - 네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7계층이었다면, 이 이론을 실제로 사용하는 인터넷 표준이 TCP/IP 4계층이다.
- TCP/IP 4계층 - 계층별 특징
  - 네트워크 인터페이스 계층(Network Access/Network Interface)
    - OSI 계층의 1,2 계층에 해당된다.
    - TCP/IP 패킷을 네트워크 매체로 전달하는 것과 네트워크 매체에서 TCP/IP 패킷을 받아들이는 과정을 담당한다.
    - 에러 검출 기능과 패킷의 프레임화 기능을 수행한다.
    - 흐름 제어(Flow Control)는 Header(MAC)에서, 에러 제어(Error Control)는 Tailer(CRC)에서 수행한다.
  - 인터넷 계층(Internet)
    - OSI 계층에서 3계층에 해당된다.
    - 어드레싱(addressing), 패키징(packaging), 라우팅(routing) 기능을 제공한다.
    - 논리적 주소인 IP를 이용한 노드간 전송과 라우팅 기능을 처리하게 된다.
    - 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공한다.
    - 핵심 프로토콜은 IP, ARP, ICMP, IGMP 등이 있다.
  - 전송 계층(Transport)
    - OSI 계층에서 3,4 계층에 해당된다.
    - 자료의 송수신을 담당한다.
    - 어플리케이션 계층의 세션과 데이터그램 통신서비스를 제공한다.
    - TCP/UDP가 핵심 프로토콜이다. TCP/UDP에 대한 구분을 하고 데이터에 대한 제어 정보가 여기에 포함된다.
  - 응용 계층(Application)
    - 다른 계층의 서비스에 접근할 수 있게 하는 어플리케이션을 제공한다.
    - 어플리케이션들이 데이터를 교환하기 위해 사용하는 프로토콜을 정의한다.
    - TCP/IP 네트워크를 사용하거나 관리하는 것을 도와주는 프로토콜이다.
- Ref.
[DevOwen](https://devowen.com/344),
[Im-D](https://github.com/im-d-team/Dev-Docs/blob/master/Network/OSI7%20Layer.md)
<br><br><br>



## TCP vs UDP
- TCP(Transmission Control Protocol)
  - TCP는 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜이다.
  - 일반적으로 TCP와 IP가 함께 사용되는데, IP가 데이터의 전송을 처리한다면 TCP는 패킷을 추적하고 관리하는 역할을 한다.
  - 연결 지향형인 TCP는 3-way handshaking이라는 과정을 통해 연결 후 통신을 시작하는데, 흐름 제어와 혼잡 제어를 지원하며 데이터의 순서를 보장한다.
  - UDP에 비하여 전송속도가 느리다.
  - 신뢰성이 높다.
- UDP(User Datagram Protocol)
  - UDP는 비연결형 프로토콜이다.
  - 인터넷상에서 서로 정보를 주고받을 때, 신호 절차를 거치지 않고 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜이다.
  - TCP와는 다르게 연결 설정이 없으며, 혼잡 제어를 하지 않기 때문에 TCP보다 전송 속도가 빠르다.
  - 데이터 전송에 대한 보장을 하지 않기 때문에 패킷 손실이 발생할 수 있다.
  - 패킷 오버헤드가 적어 네트워크 부하가 감소한다.
  - 신뢰성이 낮다.
- Ref.
[코딩 공부 일지](https://cocoon1787.tistory.com/757)
<br><br><br>



## 3-Way handshake & 4-Way hadnshake
- 3-Way Handshake란?
  - TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 뜻한다.
- 3-Way Handshake의 동작 순서
  - ![image](https://github.com/1992choi/today-i-learned/assets/27760576/205cb3fd-340a-43d3-be51-5acaacb663d6)
  - Step1. SYN
    - Client가 Server에게 접속을 요청하는 SYN플래그를 보낸다.
  - Step2. SYN + ACK
    - Server는 Listen상태에서 SYN이 들어온 것을 확인하고 SYN_RECV상태로 바뀌어 SYN + ACK플래그를 Client에게 전송한다.
    - 그 후 Server는 다시 ACK 플래그를 받기 위해 대기상태로 변경된다.
  - Step3. ACK
    - SYN + ACK 상태를 확인한 Client는 서버에게 ACK를 보내고 연결 성립(Established)이 된다.
- 4-Way Handshake란?
  - 3-Way handshake가 연결확립을 위해 진행했다면 4way handshake는 세션을 종료하기 위해 수행되는 절차를 뜻한다.
- 4-Way Handshake의 동작 순서
  - ![image](https://github.com/1992choi/today-i-learned/assets/27760576/41c81252-70d4-4856-a598-bb5ce59aa11d)
  - Step1. FIN
    - Client가 연결을 종료하겠다는 FIN플래그를 전송한다.
    - 보낸 후에 FIN-WAIT-1 상태로 변한다.
  - Step2. ACK
    - FIN 플래그를 받은 Server는 확인메세지인 ACK를 Client에게 보내준다.
    - 그 후 CLOSE-WAIT상태로 변한다.
    - Client도 마찬가지로 Server에서 종료될 준비가 됐다는 FIN을 받기위해 FIN-WAIT-2 상태가 된다.
  - Step3. FIN
    - Close준비가 다 된 후 Server는 Client에게 FIN 플래그를 전송한다.
  - Step4. ACK
    - Client는 해지 준비가 되었다는 정상응답인 ACK를 Server에게 보내준다. 이 때, Client는 TIME-WAIT 상태로 변경된다.
    - 여기서 TIME-WAIT 상태는 의도치않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지하기 위해 변경 되는 것인데, 만약 에러로 인해 종료가 지연되다가 타임이 초과되면 CLOSED 상태로 변경된다.
- Ref.
[나의 과거일지](https://jeongkyun-it.tistory.com/180)
<br><br><br>



## 교착상태(Deadlock)
- 교착상태란?
  - 일련의 프로세스들이 서로가 가진 자원을 기다리며 block되어, 더 이상 진행이 될 수 없는 상태를 의미한다.
  - 즉, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 일컫는다.
- 교착상태 발생조건
  - 다음의 4가지 조건을 모두 성립해야 데드락이 발생한다.
    - 상호 배제
      - 매 순간 하나의 프로세스만이 자원을 사용할 수 있다.
    - 점유 대기
      - 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유하고 있는 자원을 놓지 않고 계속 가지고 있다.
    - 비선점
      - 프로세스는 OS에 의해 강제로 자원을 빼앗기지 않는다.
      - 즉, 자원을 강제로 빼앗는게 아니라, 자원을 점유하고 있는 프로세스가 해당 자원을 해제해야 한다는 것이다.
    - 순환 대기
      - 자원을 기다리는 프로세스 간에 사이클이 형성어되야 한다.
- 교착상태 해결법
  - 데드락 예방(Prevention)
    - 자원의 상호 배제 조건 방지
      - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게한다. (단, 동기화 관련 문제가 발생할 수 있다.)
    - 점유 대기 조건 방지
      - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.
    - 비선점 조건 방지
      - 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
    - 순환 대기 조건 방지
      - 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.
  - 데드락 회피(Avoidance)
    - 데드락 회피법에서는 Safe sequence, Safe state 등이 키워드이다.
    - 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 안정 상태(safe state)에 있다고 말한다.
    - 그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서(safe sequence)라고 부른다.
    - 회피 알고리즘(Ex. 은행원 알고리즘)을 통해 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징이다.
  - 데드락 탐지(Detection) 및 회복(Recovery)
    - 시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 데드락을 탐지하고, 회복하는 알고리즘을 사용한다.
    - 탐지 기법
      - Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색한다.
      - 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.
      - 이 외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다.
    - 회복 기법
      - 데드락을 탐지 기법을 통해 발견했다면, 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법을 사용한다.
        - 단순히 프로세스를 1개 이상 중단시키기
          - 교착 상태에 빠진 모든 프로세스를 중단시키는 방법
            - 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있다.
          - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법
            - 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있다.
        - 자원 선점하기
          - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해준다.
- Ref.
[zioo](https://velog.io/@zioo/Deadlock%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EB%B0%9C%EC%83%9D-%EC%9B%90%EC%9D%B8), 
[ChanBLOG](https://chanhuiseok.github.io/posts/cs-2/),
[Gyoogle](https://github.com/gyoogle/tech-interview-for-developer/blob/b478de0481da8227913c647afb004c5d39c0718e/Computer%20Science/Operating%20System/DeadLock.md)
<br><br><br>



## 뮤텍스와 세마포어
- 임계 영역(Critical Section)이란?
  - 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록을 뜻한다.
  - 즉, 여러 프로세스가 동일 자원을 동시에 참조하여 값(공유하는 변수명, 파일 등)이 오염될 위험 가능성이 있는 영역이다.
- 뮤텍스(Mutex)와 세마포어(Semaphore)란?
  - 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 공유된 자원에 여러 개의 프로세스가 동시에 접근하면 Critical Section 문제가 발생할 수 있다.
  - 이를 해결하기 위해 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야 하는데, 대표적인 동기화 도구에는 뮤텍스와 세마포어가 있다.
- 뮤텍스(Mutex)
  - 동시 프로그래밍에서 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다.
  - 임계구역(Critical Section)을 가진 스레드들의 실행시간(Running Time)이 서로 겹치지 않고 각각 단독으로 실행되도록 하는 기술이다.
  - 한 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법이다.
  - 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 동기화(Synchronization) 또는 락(Lock)을 사용한다.
  - 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.
- 세마포어(Semaphore)
  - 멀티 프로그래밍 환경에서 공유된 자원에 대한 접근을 제한하는 방법이다.
  - 사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성한다.
  - 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있다.
  - 각 프로세스는 세마포어의 값을 확인하고 변경할 수 있다.
  - 자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용한다.
  - 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면, 재시도 전에 일정시간 대기해야 한다.
  - 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 대기하도록 해야 한다.
  - 세마포어는 이진수를 사용하거나 추가적인 값을 가질 수 있다.
- 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점
  - 가장 큰 차이점은 동기화 대상의 갯수이다. 뮤텍스는 동기화 대상이 오직 1개일 때 사용하고, 세마포어는 동기화 대상이 1개 이상일 때 사용한다.
  - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
  - 뮤텍스는 자원 소유가 가능한 반면에 세마포어는 자원 소유가 불가능하다.
  - 뮤텍스는 소유하고 있는 스레드만이 이 뮤텍스를 해제할 수 있지만 세마포어는 세마포어를 소유하지 않은 스레드가 세마포어를 해제할 수 있다.
  - 세마포어는 시스템 범위에 걸쳐있고, 파일 시스템상에 파일로 존재하는 반면에 뮤텍스는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up된다.
- Ref.
[굳세게 코딩하는 단발머리 첼씨✨](https://chelseashin.tistory.com/40)
<br><br><br>



## 단방향 암호화와 양방향 암호화
- 암호화란?
  - 평문을 특정 키를 사용해서 해독할 수 없는 형태로 변경하는 것을 뜻한다.
  - 암호화 방식에는 단방향 암호화와 양방향 암호화 방식이 있다.
  - ![image](https://github.com/1992choi/today-i-learned/assets/27760576/2a8f6ab3-a3f9-4046-897c-cf182b606f3f)
- 단방향 암호화
  - 평문을 암호화하는 것은 가능하지만 암호문을 평문으로 복호화할 수 없는 기법.
  - 대표적으로 HASH를 사용한 방식이 있다.
- 양방향 암호화
  - 암호문을 평문으로 복호화할 수 있는 기법.
  - 양방향 암호화는 크게 대칭키(비공개키)와 비대칭키(공개키)방식으로 나눠진다.
  - 대칭키 방식은 암호화, 복호화시 모두 동일한 키를 사용하고, 비대칭키(공개키)방식은 암호화 복호화에 서로 다른 키를 사용한다.
   - 대칭키(비공개키) 방식
      - 암/복호화에 서로 동일한 키가 사용되는 암호화 방식.
      - 장점
        - 비대칭키보다 속도가 빠르다.
      - 단점
        - 키를 교환해야하는 키 배송 문제가 발생한다.
        - 키를 교환하는 도중에 키가 탈취될 수 있다.
        - 사람이 증가할수록 각자 따로 키를 교환해야하므로 관리해야할 키가 방대해진다.
      - 종류
        - AES, DES 알고리즘
    - 비대칭키(공개키) 방식
      - 암/복호화에 다른 키가 사용되는 방식
      - 노출시켜도 상관없는 Public Key와 노출시켜서는 안되는 Private Key로 구성된다.
      - 장점
        - 공개키는 공개되어있기 떄문에 키 교환이 필요없다.
        - 개인키를 가지고 있는 수신자만이 복호화할 수 있으므로 인증 기능을 할 수 있다.
      - 단점
        - 대칭키 방식에 비해 속도가 느리다.
      - 종류
        - RSA 알고리즘
- Ref.
[jummi10.log](https://velog.io/@jummi10/%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%95%94%ED%98%B8%ED%99%94-vs-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%95%94%ED%98%B8%ED%99%94),
[자바공작소](https://javaplant.tistory.com/26)
<br><br><br>



## 고정 소수점과 부동 소수점
- 실수의 표현 방식
  - 컴퓨터에서 실수를 표현하는 방법에는 크게 고정 소수점 방식과 부동 소수점 방식이 있다.
- 고정 소수점 방식
  - 정수를 표현하는 비트와 소수를 표현하는 비트 수를 미리 고정하고 해당 비트만을 활용하여 실수를 표현한다.
    - ![image](https://github.com/1992choi/today-i-learned/assets/27760576/3eb00f8f-fde6-4719-89d4-dd01b6553b85)
    - 처음 1비트는 sign(부호)을 나타낸다. (0은 양수, 1은 음수)
    - 다음 15비트는 integer part(정수부)를 나타낸다.
    - 다음 16비트는 fractional part(소수부)를 나타낸다.
  - 장점
    - 표현하는 방법이 단순하다.
    - 연산속도가 빠르다.
  - 단점
    - 표현할 수 있는 범위가 적다.
    - 정밀도가 낮다.
- 부동 소수점 방식
  - 정수를 표현하는 비트와 소수를 표현하는 비트 수가 유동적이다.
    - ![image](https://github.com/1992choi/today-i-learned/assets/27760576/e1c374d0-b98e-4924-ae1d-e4a053110623)
    - 2진수를 정규화 한다.
    - 처음 1비트는 sign(부호)를 나타낸다. (0은 양수, 1은 음수)
    - 다음 8비트는 exponent(지수부)를 나타낸다.
    - 다음 23비트는 mantissa(가수부)를 나타낸다.
  - 장점
    - 더 큰 실수를 표현할 수 있다.
  - 단점
    - 실수 연산이 부정확할 수 있다.
      - 예를 들어 십진수 0.3을 2진수로 변환하면 0.0100110011...(2) 처럼 특성 수가 무한이 반복된다. 따라서 컴퓨터가 실수 부분을 표현할 수 있는 비트 수를 다 써버리게 되어 근사치로 표현되게 된다.
- 부동 소수점의 저장
  - 부동 소수점은 근사값으로 표현되기 때문에 오차가 발생하기도 한다.
    - JAVA에서의 오차 해결
      - BigDecimal 클래스를 사용한다.
    - DB에서의 오차 해결
      - DECIMAL타입을 사용하여 부동 소수점을 고정 소수점 방식으로 사용한다.
- Ref.
[MeongKune_Developer](https://velog.io/@meongkune/%EA%B3%A0%EC%A0%95-%EC%86%8C%EC%88%98%EC%A0%90-vs.-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90),
[MJ](https://velog.io/@devp1023/%EC%88%98%ED%95%99-%EA%B3%A0%EC%A0%95-%EC%86%8C%EC%88%98%EC%A0%90%EA%B3%BC-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90),
[bahngju의 개발 블로그](https://bahngju.tistory.com/8),
[WOONY's 인사이트](https://woonys.tistory.com/279)
<br><br><br>





<br><br><br>
- - -
