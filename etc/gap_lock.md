# MySQL Gap Lock 데드락 분석

## 1. Gap Lock이란?

### 1.1 정의
Gap Lock은 InnoDB 스토리지 엔진에서 **인덱스 레코드 사이의 간격(gap)에 대한 잠금**입니다. 실제 존재하는 레코드가 아닌, 레코드와 레코드 사이의 빈 공간에 대한 잠금을 의미합니다.

### 1.2 Gap Lock의 목적
- **Phantom Read 방지**: REPEATABLE READ 격리 수준에서 동일한 쿼리를 두 번 실행했을 때 결과가 달라지는 것을 방지
- 트랜잭션 격리성 보장
- 같은 트랜잭션 내에서 일관된 데이터 읽기 보장

### 1.3 Gap Lock이 발생하는 조건
1. **격리 수준**: REPEATABLE READ 이상
2. **인덱스 사용**: WHERE 절에서 인덱스를 사용한 범위 검색
3. **쿼리 유형**: SELECT ... FOR UPDATE, UPDATE, DELETE 등

## 2. Lock의 종류

### 2.1 Record Lock
- **실제 존재하는 인덱스 레코드**에 대한 잠금
- 특정 행(row)을 잠금
- 다른 트랜잭션이 해당 레코드를 수정/삭제하지 못하게 함

### 2.2 Gap Lock
- **인덱스 레코드 사이의 간격**에 대한 잠금
- 실제 데이터가 없는 빈 공간을 잠금
- 새로운 INSERT를 방지
- 여러 트랜잭션이 동일한 Gap에 대해 공유 잠금 가능

### 2.3 Next-Key Lock
- Record Lock + Gap Lock의 조합
- 레코드 자체 + 그 앞의 간격을 함께 잠금
- InnoDB의 기본 잠금 방식
- REPEATABLE READ에서 Phantom Read를 방지하는 핵심 메커니즘

## 3. Gap Lock의 범위

### 3.1 간격의 개념
인덱스 값이 10, 20, 30, 40, 50이라고 가정하면:

```
(-∞, 10)     ← 10 이전의 간격
(10, 20)     ← 10과 20 사이의 간격
(20, 30)     ← 20과 30 사이의 간격
(30, 40)     ← 30과 40 사이의 간격
(40, 50)     ← 40과 50 사이의 간격
(50, +∞)     ← 50 이후의 간격
```

### 3.2 범위 검색 시 Gap Lock
BETWEEN 조건으로 20에서 40까지 검색하면:
- Record Lock: 20, 30, 40
- Gap Lock: (20, 30), (30, 40)
- 결과적으로 20~40 사이에 새로운 값 INSERT 불가

### 3.3 IN 절 사용 시 Gap Lock
IN 절에 여러 값을 지정하면 (예: 10, 30, 50):
- Record Lock: 10, 30, 50
- Gap Lock: (-∞, 10), (10, 20), (20, 30), (30, 40), (40, 50), (50, +∞)
- **각 값마다 앞뒤 간격에 모두 Gap Lock 발생**
- IN 절의 값이 많을수록 Gap Lock 범위가 넓어짐

## 4. Secondary Index와 Gap Lock

### 4.1 복합 인덱스의 Gap Lock
복합 인덱스 (컬럼A, 컬럼B)가 있을 때, IN 절로 컬럼A의 여러 값을 조회하면:
- 컬럼A의 각 값마다 독립적인 Gap Lock 발생
- 예: 컬럼A IN (1, 2, 3) → 1, 2, 3 각각에 대해 Gap Lock

### 4.2 Primary Key vs Secondary Index

**Primary Key 사용 시:**
- Gap Lock 범위가 명확하고 좁음
- PK 값 기준으로만 간격 형성
- 다른 PK 범위와 충돌 가능성 낮음

**Secondary Index 사용 시:**
- Gap Lock 범위가 넓고 복잡함
- 인덱스 컬럼 값 기준으로 간격 형성
- 여러 PK가 같은 Gap에 포함될 수 있음
- 인덱스 순서와 PK 순서가 다를 수 있어 예측 어려움

## 5. 데드락 발생 원리

### 5.1 데드락의 기본 조건
1. **상호 배제(Mutual Exclusion)**: 리소스는 한 번에 하나의 트랜잭션만 사용
2. **점유와 대기(Hold and Wait)**: 리소스를 보유한 채 다른 리소스 대기
3. **비선점(No Preemption)**: 리소스를 강제로 빼앗을 수 없음
4. **순환 대기(Circular Wait)**: 트랜잭션들이 순환 형태로 서로 대기

### 5.2 Gap Lock 데드락 시나리오

**상황 설정:**
- 복합 인덱스 사용
- IN 절로 여러 값 조회
- 트랜잭션 A와 B가 서로 다른 PK 범위를 병렬 처리

**데드락 발생 과정:**

**Step 1: 트랜잭션 A 시작**
- 첫 번째 인덱스 값 검색 시작
- 해당 범위에 Gap Lock 획득
- 두 번째 인덱스 값 검색으로 진행

**Step 2: 트랜잭션 B 시작**
- 첫 번째 인덱스 값 검색 시도
- Gap Lock 대기 (A가 보유 중)
- 대기 상태 진입

**Step 3: 트랜잭션 A 계속 진행**
- 두 번째 인덱스 값 검색 완료, Gap Lock 획득
- 세 번째 인덱스 값 검색 시도
- 만약 B가 이미 해당 범위를 잡았다면 대기

**Step 4: 데드락 발생**
- A는 B가 잡은 리소스를 기다림
- B는 A가 잡은 리소스를 기다림
- **순환 대기 발생 → DEADLOCK**
- MySQL이 데드락 감지하여 한 트랜잭션 롤백

### 5.3 왜 PK 범위가 달라도 데드락이 발생하는가?

**핵심 포인트:**
- Gap Lock은 **인덱스 순서대로** 발생
- PK 범위는 **데이터의 물리적 위치**를 의미
- Secondary Index는 **논리적 순서**를 의미
- 두 순서가 일치하지 않으면 충돌 가능

**구체적 설명:**

PK와 인덱스 컬럼의 값 분포가 다르기 때문입니다.
- PK 1~10 범위에 인덱스 값 100, 200, 300이 섞여있을 수 있음
- PK 11~20 범위에도 인덱스 값 100, 200, 300이 섞여있을 수 있음
- 인덱스 스캔은 PK 순서가 아닌 인덱스 컬럼 순서로 진행
- 따라서 서로 다른 PK 범위를 처리해도 동일한 인덱스 범위를 스캔
- 결과적으로 동일한 Gap Lock을 시도하게 됨

**결론:**
- BETWEEN으로 제한한 PK 범위는 **필터링 조건**일 뿐
- Gap Lock 범위는 **인덱스 스캔 범위**에 의해 결정
- IN 절에 포함된 모든 값에 대해 Gap Lock 발생
- PK 범위가 겹치지 않아도 인덱스 범위가 겹치면 데드락 가능

## 6. Gap Lock과 인덱스 선택

### 6.1 인덱스 선택의 중요성
MySQL Optimizer가 어떤 인덱스를 선택하느냐에 따라 Gap Lock 범위가 완전히 달라집니다.

**Case 1: PRIMARY KEY 선택**
- PK 기준으로 순차 스캔
- 각 레코드에서 조건 확인 (필터링)
- Gap Lock이 PK 범위에만 제한됨
- 다른 PK 범위와 충돌 없음

**Case 2: Secondary Index 선택**
- 인덱스 컬럼 기준으로 스캔
- 인덱스의 각 값에서 PK 확인 (필터링)
- Gap Lock이 인덱스 전체 범위에 발생
- 다른 PK 범위와 충돌 가능

### 6.2 IN 절과 인덱스의 관계
IN 절은 여러 개의 OR 조건으로 해석되며:
- 각 OR 조건마다 별도의 인덱스 스캔
- 각 스캔마다 별도의 Gap Lock 발생
- 모든 Gap이 합쳐져서 전체 잠금 범위 형성
- 값이 많을수록 Gap Lock 범위도 증가

## 7. 격리 수준과 Gap Lock

### 7.1 READ UNCOMMITTED
- Gap Lock 없음
- Record Lock만 사용
- Dirty Read 가능 (커밋되지 않은 데이터 읽기)
- 가장 낮은 격리 수준, 가장 높은 성능

### 7.2 READ COMMITTED
- Gap Lock 없음
- Record Lock만 사용
- Phantom Read 가능 (같은 쿼리에서 다른 결과)
- Non-repeatable Read 가능
- 데드락 위험 낮음

### 7.3 REPEATABLE READ (InnoDB 기본값)
- Gap Lock 사용
- Next-Key Lock 사용
- Phantom Read 방지
- Repeatable Read 보장
- 데드락 위험 증가

### 7.4 SERIALIZABLE
- Gap Lock 사용
- 모든 SELECT가 자동으로 잠금 획득
- 가장 엄격한 격리
- 가장 낮은 성능
- 데드락 위험 가장 높음

## 8. Gap Lock의 특성

### 8.1 공유 가능한 잠금
Gap Lock은 특이하게 **공유(Shared) 잠금** 특성이 있습니다:
- 여러 트랜잭션이 같은 Gap에 대해 동시에 Gap Lock을 가질 수 있음
- 하지만 누구도 그 Gap에 INSERT할 수 없음
- Gap Lock끼리는 충돌하지 않음
- Gap Lock과 Insert Intention Lock이 충돌

### 8.2 Insert Intention Lock
새로운 레코드를 INSERT하려면:
- Insert Intention Lock을 먼저 획득해야 함
- Insert Intention Lock은 Gap Lock과 **충돌**
- Gap Lock이 있는 동안에는 해당 Gap에 INSERT 불가능
- INSERT가 대기하거나 타임아웃

### 8.3 동일한 Gap에 대한 경쟁
**시나리오:**
- 트랜잭션 A: 특정 범위에 Gap Lock 보유
- 트랜잭션 B: 해당 범위에 INSERT 시도
- 트랜잭션 C: 동일 범위에 SELECT ... FOR UPDATE

**결과:**
- A와 C는 동시에 Gap Lock 보유 가능 (Gap Lock끼리는 충돌 안함)
- B는 A 또는 C가 커밋/롤백할 때까지 대기 (Insert Intention Lock과 Gap Lock 충돌)

## 9. 실제 데드락 발생 사례

### 9.1 발생 환경
- **처리 방식**: 배치 작업에서 5개 스레드가 병렬로 서로 다른 PK 범위 처리
- **트랜잭션 격리 수준**: REPEATABLE READ
- **사용 인덱스**: Secondary Index (복합 인덱스)
- **쿼리 조건**: IN 절로 여러 값 조회 + PK 범위 제한

### 9.2 병렬 처리 구조
```
Thread 1: PK 범위 A   ─┐
Thread 2: PK 범위 B    ├─ 동시 실행
Thread 3: PK 범위 C    │  동일한 IN 절 조건 사용
Thread 4: PK 범위 D    │
Thread 5: PK 범위 E   ─┘
```

### 9.3 데드락 발생 과정

**Thread 1 실행:**
- 첫 번째 인덱스 값 스캔 시작
- 해당 범위에 Gap Lock 획득
- 두 번째 인덱스 값 스캔 시작
- 해당 범위에 Gap Lock 획득
- 세 번째 인덱스 값 스캔 시작... (대기 가능)

**Thread 2 실행 (거의 동시):**
- 첫 번째 인덱스 값 스캔 시도
- Gap Lock 대기 (Thread 1이 보유 중)

**Thread 3 실행 (거의 동시):**
- 첫 번째 인덱스 값 스캔 시도
- Gap Lock 대기

**결과:**
- Thread 1: 일부 인덱스 범위 보유, 다른 범위 대기
- Thread 2: 일부 인덱스 범위 대기
- Thread 3: 일부 인덱스 범위 대기
- 어떤 조합으로든 **순환 대기 발생 가능**
- MySQL이 데드락 감지하여 한 트랜잭션 롤백

### 9.4 왜 발생했는가?

**예상:**
- PK 범위가 겹치지 않으니 충돌 없을 것

**실제:**
- MySQL이 Secondary Index 선택
- IN 절로 여러 인덱스 값 조회
- 각 인덱스 값에 대해 전체 범위 Gap Lock 발생
- PK BETWEEN은 단순 필터링 조건
- 5개 스레드가 모두 동일한 Gap Lock 범위에 접근
- 서로 다른 순서로 Lock 획득 시도 → 데드락

## 10. 해결 방안

### 10.1 방안 1: PRIMARY KEY 강제 사용 (권장)

**개념:**
- 쿼리 힌트를 사용하여 PRIMARY KEY 인덱스 강제 선택
- Gap Lock 범위가 PK 범위로 제한됨
- 서로 다른 PK 범위는 Gap Lock이 겹치지 않음

**장점:**
- 성능 영향 최소
- 로직 변경 불필요
- 데드락 위험 대폭 감소

**단점:**
- 필터링 조건이 인덱스를 사용하지 못함
- 필터링 컬럼의 카디널리티가 높으면 성능 저하 가능

### 10.2 방안 2: 격리 수준을 READ COMMITTED로 변경

**개념:**
- 트랜잭션 격리 수준을 REPEATABLE READ에서 READ COMMITTED로 변경
- READ COMMITTED에서는 Gap Lock이 발생하지 않음
- Record Lock만 사용

**장점:**
- Gap Lock이 발생하지 않음
- 데드락 가능성 대폭 감소
- 쿼리 변경 불필요

**단점:**
- Phantom Read 가능성
- 트랜잭션 내 일관성 저하
- 비즈니스 로직에 따라 허용 불가능할 수 있음

### 10.3 방안 3: IN 절을 단일 값 조회로 분리

**개념:**
- IN 절로 한 번에 조회하는 대신 각 값을 순차적으로 조회
- 각 조회마다 독립적인 Gap Lock 발생
- Gap Lock 충돌 범위 축소

**장점:**
- Gap Lock 충돌 범위 축소
- 각 값마다 독립적인 잠금

**단점:**
- 쿼리 실행 횟수 증가
- 네트워크 오버헤드 증가
- 전체 처리 시간 증가 가능

### 10.4 방안 4: 데드락 재시도 로직 추가

**개념:**
- 데드락 발생 시 자동으로 재시도하는 로직 구현
- 일시적인 경합 상황에서 효과적
- Spring Retry 등의 프레임워크 활용 가능

**장점:**
- 다른 로직 변경 불필요
- 일시적 경합 상황 해결
- 구현이 비교적 간단

**단점:**
- 근본적인 해결책은 아님
- 재시도로 인한 지연 발생
- 데드락이 지속적으로 발생하면 실패

### 10.5 방안 5: 락 획득 순서 통일

**개념:**
- 모든 트랜잭션이 동일한 순서로 리소스에 접근
- 순환 대기 방지
- IN 절의 값을 항상 정렬하여 사용

**장점:**
- 순환 대기 원천 차단
- 데드락 발생 방지

**단점:**
- 병렬 처리의 이점 일부 상실
- 처리 시간 증가 가능
- 구현 복잡도 증가

## 11. 권장 해결 방안 조합

### 11.1 단기 해결책
1. **PRIMARY KEY 강제 사용** + **데드락 재시도**
2. 즉시 적용 가능
3. 성능 영향 최소

### 11.2 장기 해결책
1. **READ COMMITTED 격리 수준** 검토
2. 비즈니스 요구사항 확인 필요
3. Phantom Read 허용 가능 여부 검토
4. 충분한 테스트 후 점진적 적용

## 12. 핵심 요약

### Gap Lock의 본질
- 인덱스 레코드 사이의 간격에 대한 잠금
- Phantom Read 방지를 위해 존재
- REPEATABLE READ 이상에서만 발생

### 데드락 발생 핵심 원인
1. **Secondary Index 사용**: 인덱스 순서로 Gap Lock 발생
2. **IN 절 사용**: 각 값마다 별도의 Gap Lock
3. **병렬 처리**: 여러 트랜잭션이 동시에 동일한 Gap 접근
4. **서로 다른 순서**: Lock 획득 순서가 달라 순환 대기

### PK 범위가 달라도 데드락이 발생하는 이유
- Gap Lock은 **인덱스 순서**로 발생
- PK 범위는 **물리적 위치**, 인덱스 순서는 **논리적 위치**
- 두 개념이 일치하지 않으면 충돌 가능
- 범위 제한 조건은 필터링일 뿐, Gap Lock 범위에 영향 없음

### 해결의 핵심
1. **PRIMARY KEY 사용**: Gap Lock 범위를 PK로 제한
2. **READ COMMITTED**: Gap Lock 자체를 비활성화
3. **재시도 로직**: 임시 경합 상황 대응
4. **순서 통일**: 순환 대기 방지

### 트레이드오프
- **REPEATABLE READ + Gap Lock**: 격리성 ↑, 성능 ↓, 데드락 ↑
- **READ COMMITTED**: 격리성 ↓, 성능 ↑, 데드락 ↓
- **PRIMARY KEY 강제**: 데드락 ↓, 필터링 성능 ↓
- **재시도**: 안정성 ↑, 처리 시간 변동 ↑
